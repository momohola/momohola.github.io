<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（十五）光线追踪（蒙特卡洛积分与路径追踪）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本节涉及内容：</p><ul><li>蒙特卡罗积分</li><li>路径追踪</li></ul><h2 id="蒙特卡罗积分"><a href="#蒙特卡罗积分" class="headerlink" title="蒙特卡罗积分"></a>蒙特卡罗积分</h2><p><strong>蒙特卡罗积分</strong>的核心思想还是求一个不规则图形的面积，它的做法是：首先在a和b之间找一个值x<del>i</del>然后求f（x）。接着以f（x）为高，ab为宽求矩形的面积，最后将所有的值求平均。当采样数量x<del>i</del>趋于无穷时，就近似求到了该不规则图形的面积。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="怎么求蒙特卡罗积分"><a href="#怎么求蒙特卡罗积分" class="headerlink" title="怎么求蒙特卡罗积分"></a>怎么求蒙特卡罗积分</h2><p>**F<del>N</del>**表示蒙特卡罗积分<br><strong>X~i~~p（x）</strong>表示概率分布<br>因为我们取x<del>i</del>时是在a到b之间均匀的取值，所以x<del>i</del>在ab上服从均匀分布。由均匀分布的概率密度函数可知  C&#x3D;1&#x2F;(b-a)<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167106284051.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167106284052.png" alt="在这里插入图片描述"><br>即p（x<del>i</del>）&#x3D;1&#x2F;(b-a)代入可得<br>从该式子可以看出，蒙特卡罗积分的思想：f(x<del>i</del>)表示图形的高度，b-a表示图形的宽度，1&#x2F;N表示求平均值。这就从侧面说明了蒙特卡罗积分的核心思想。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167106284063.png" alt="在这里插入图片描述"><br><strong>求蒙特卡罗积分所需的条件：</strong></p><ul><li>知道曲线上任何一个点的函数值，即f（x<del>i</del>）</li><li>知道采样的概率密度p（x<del>i</del>）</li></ul><h2 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h2><p>这两个茶壶，左边这个完全光滑，是镜面反射，右边这个相对来讲没有那么光滑。在Whitted-Style Ray Tracing下，对于镜面反射的物体来讲没有什么问题，但是对于表面有些粗糙的物体，反射的光线应该朝向各个方向，如果认为还是认为沿着镜面反射方向反射，是不对的，因此这里产生了问题。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167106284064.png" alt="在这里插入图片描述"><br>场景中的物体都是漫反射的，而如果用Whitted-style ray tracing，其定义当光线打到漫反射物体，那么这条光线就停下来了，那么两个物体之间的光线全部都得不到。右边是全局光照，光线打到一个漫反射物体上时，仍然继续传播直到射到我们的眼睛里，所有我们可以看到黑暗的地方。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167106284065.png" alt="在这里插入图片描述"><br>因为Whitted-style ray tracing在物理上是错误的，所以需要一个之前的东西来替代它。即渲染方程<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167106284076.png" alt="在这里插入图片描述"><br>可以观察到渲染方程右边是一个积分，所以我们可以用蒙特卡罗积分来解。</p><p>在这一个简单场景中，我们就考虑清楚对于一个点（像素），他的直接光照是什么。</p><ul><li>有可能有其他物体会挡住光</li><li>有一个相对较大的面光源</li><li>观测方向：着色点到摄像机的方向ωo</li><li>各个不同的进来的光（入射光方向）：ωi（与Blinn-Phong一样，认为方向都是从着色点出发往外打）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167106284077.png" alt="在这里插入图片描述"><br>对于一个着色点而言，它的光就是四面八方来的光被反射到观察点的光。（不考虑自发光）<br>反射方程如下：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167106284078.png" alt="在这里插入图片描述"></li></ul><p><strong>那么怎么求这个渲染方程呢？</strong></p><p>由蒙特卡罗积分可知要求一个积分要知道被积函数f（x）和概率密度p（x）</p><p>因为球的面积是4π，所以半球面积是2π，概率密度就是球上每一个点的均值即1&#x2F;2π<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167106284079.png" alt="在这里插入图片描述"><br>将反射方程写成蒙特卡罗积分的形式<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840710.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">shade(p, wo)<br>Randomly choose N directions wi~pdf<span class="hljs-comment">//随机选择n个采样点</span><br>Lo = <span class="hljs-number">0.0</span><br>For each wi<br>Trace a ray r(p, wi)<br>If ray r hit the light<br>Lo += (<span class="hljs-number">1</span> / N) * L_i * f_r * cosine / pdf(wi)<span class="hljs-comment">//表示渲染方程</span><br>Return Lo<br></code></pre></td></tr></table></figure><p>到此为止只是解决了直接光照的问题，但是我们最后的结果要是全局光照，因此再引入间接光照</p><p>因此我们需要计算由Q反射到P的光照，这个时候我们类比，就好像是在P点观察Q点，算出Q点的直接光照。Q点反射到P点的Radiance就相当于是在Q点算出的直接光照。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840811.png" alt="在这里插入图片描述"><br>但是这样做就会产生一个问题，假如说一根光线射到一个物体上，反射出了一百根光线，然后又射到另一个物体上那就是一万根了，它是以指数级增长的，这样计算量太大了。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840812.png" alt="在这里插入图片描述"><br>只有当N&#x3D;1时计算量才时在可接受范围内，所以算法可以进行如下改进。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">shade(p, wo)<br>Randomly choose ONE direction wi~pdf(w)   <span class="hljs-comment">//只采样一次</span><br>Trace a ray <span class="hljs-title function_">r</span><span class="hljs-params">(p, wi)</span><br>If ray r hit the light<br>Return L_i * f_r * cosine / <span class="hljs-title function_">pdf</span><span class="hljs-params">(wi)</span><br>Else If ray r hit an object at q<br>Return <span class="hljs-title function_">shade</span><span class="hljs-params">(q, -wi)</span> * f_r * cosine / <span class="hljs-title function_">pdf</span><span class="hljs-params">(wi)</span><span class="hljs-comment">//这里进行递归，计算间接光照</span><br></code></pre></td></tr></table></figure><p>当N&#x3D;1时，这种追踪方式叫做<strong>路径追踪</strong><br>当N!&#x3D;1时，这种追踪方式叫做<strong>分布式光线追踪</strong>（计算量爆炸多）</p><p>虽然N&#x3D;1会造成很大的噪声，但是穿过一个像素可以有很多条路径，然后对于这些路径求平均即可降低每条路径对于最终结果的影响。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840813.png" alt="在这里插入图片描述"><br>下面是该方法的算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">ray_generation(camPos, pixel)<span class="hljs-comment">//camPos摄像机的位置，pixel待计算的像素值</span><br>Uniformly choose N sample positions within the pixel   <span class="hljs-comment">//在这个像素内均匀的取N个不同的位置</span><br>pixel_radiance = <span class="hljs-number">0.0</span><br>For each sample in the pixel  <span class="hljs-comment">//对于任何一个位置都发射一条光线</span><br>Shoot a ray r(camPos, cam_to_sample) <br>If ray r hit the scene at p  <span class="hljs-comment">//如果打到了场景中</span><br>pixel_radiance += <span class="hljs-number">1</span> / N * shade(p, sample_to_cam)<span class="hljs-comment">//计算该光线的着色</span><br>Return pixel_radiance<br></code></pre></td></tr></table></figure><p>但是这个递归算法并没有出口，这表示光线会弹射无数次，虽然显示生活中光线的确会经过无数次的弹射，但是计算机里面没办法模拟无数次，必须停止，如果直接规定最高弹射次数就会造成光线能量的损失，所以我们需要一种方法来停止弹射：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840814.png" alt="在这里插入图片描述"></p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840815.png" alt="在这里插入图片描述"><br>这种方法的算法表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">shade(p, wo)<br>Manually specify a probability P_RR <span class="hljs-comment">//P_RR表示发射光线的概率</span><br>Randomly select ksi in a uniform dist. in [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] <span class="hljs-comment">//ksi是[0, 1]的一个随机数</span><br>If (ksi &gt; P_RR) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<span class="hljs-comment">//如果ksi大于P_RR则表示不发出关系</span><br><br>Randomly choose ONE direction wi~pdf(w)<span class="hljs-comment">//下面的算法和上面的一致</span><br>Trace a ray <span class="hljs-title function_">r</span><span class="hljs-params">(p, wi)</span><br>If ray r hit the light<br>Return L_i * f_r * cosine / <span class="hljs-title function_">pdf</span><span class="hljs-params">(wi)</span> / P_RR<br>Else If ray r hit an object at q<br>Return <span class="hljs-title function_">shade</span><span class="hljs-params">(q, -wi)</span> * f_r * cosine / <span class="hljs-title function_">pdf</span><span class="hljs-params">(wi)</span> / P_RR<br></code></pre></td></tr></table></figure><p>到此为止，这套算法就是正确的，而且可以计算间接光照的算法了。</p><p>虽然有了这套路径最终的方法但是并不高效，因为低SPP的画面效果很差，但是提高SPP后画面好，造成性能有负担。所以我们要解决的是在低SPP下也可以达到高SPP的画面效果。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840816.png" alt="在这里插入图片描述"><br>之前我们实现路径追踪是在着色点朝着四面八方均匀的射出许多光线（均匀采样），当光源越来越小时能够射到光源上的光线就越少，就会使得很多光线都浪费了<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840817.png" alt="在这里插入图片描述"><br>所以我们需要找到一个更好的pdf采样方法。</p><p>如果我们直接从光源上采样，那么所有光线都不会被浪费了</p><p>假设对于着色点在光源上采样，那么对于这个面光源来讲，光源面积是A，均匀采样的PDF就是1&#x2F;A</p><p>但是渲染方程是定义在半球中立体角上的，而不是在光源上的，</p><p>采样在光源上采样，积分在立体角上积分，如果要确保渲染方程还能用，就要把渲染方程写成在光源上的积分。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840918.png" alt="在这里插入图片描述"><br>也就是说需要将渲染方程作为dA的积分 ，那么就要找到dω和dA之间的关系</p><p>因为立体角可以理解为将一块面积投影到一个单位球的表面上，所以只需要将dA投影到单位球的表面上，求出投影的面积，就得到了立体角，所以dω和dA之间的关系有如下公式：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840919.png" alt="在这里插入图片描述"><br>把渲染方程写成在光源（dA）上的积分。那么就可以使用蒙特卡罗积分了，而且p（ω）&#x3D;1&#x2F;A<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840920.png" alt="在这里插入图片描述"><br>基于这种思想，改进的算法：</p><ul><li>第一部分来源于对光源的贡献，对光源采样</li><li>第二部分来源于其他所有非光源的贡献（如物体反射的光），这部分还用原来哪个俄罗斯轮盘赌的方法进行计算<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840921.png" alt="在这里插入图片描述"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">shade(p, wo)<br><span class="hljs-comment">//来自光源的贡献</span><br>Uniformly sample the light at x’ (pdf_light = <span class="hljs-number">1</span> / A)<span class="hljs-comment">//均匀的对光源进行采用样即（1/A）</span><br>L_dir = L_i * f_r * <span class="hljs-built_in">cos</span> θ * <span class="hljs-built_in">cos</span> θ’ / |x’ - p|^<span class="hljs-number">2</span> / pdf_light <span class="hljs-comment">//写成dA形式的渲染方程</span><br><br><span class="hljs-comment">//来自其他点的贡献，采用以前的俄罗斯轮盘赌方法</span><br>L_indir = <span class="hljs-number">0.0</span><br>Test Russian Roulette with probability P_RR<br>Uniformly sample the hemisphere toward wi (pdf_hemi = <span class="hljs-number">1</span> / <span class="hljs-number">2</span>pi)<br>Trace a ray r(p, wi)<br>If ray r hit a non-emitting object at q  <span class="hljs-comment">//打到了点q，确定点q不是光源（因为光源的贡献已经算出来了）</span><br>L_indir = shade(q, -wi) * f_r * <span class="hljs-built_in">cos</span> θ / pdf_hemi / P_RR<br>Return L_dir + L_indir<br></code></pre></td></tr></table></figure><p>左是照片，右边是通过路径追踪渲染出来的图像，几乎和现实一模一样。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671062840922.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（十四）光线追踪（辐射度量学、渲染方程与全局光照）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本节涉及内容：</p><ul><li>辐射度量学（Basic radiometry）</li><li>光线的传播：反射方程以及渲染方程</li><li>全局光照</li></ul><p>为什么要学辐射度量学？<br>之前使用的Whittled style光线追踪很多物理量都没有精确的定义，导致生成的图像不真实。总之就是Whittled style光线追踪太拉了，需要一个更好的方法来代替。</p><h2 id="辐射度量学（Basic-radiometry）"><a href="#辐射度量学（Basic-radiometry）" class="headerlink" title="辐射度量学（Basic radiometry）"></a>辐射度量学（Basic radiometry）</h2><ul><li>辐射度量学主要是用来描述光照的</li><li>它定义了一系列的方法以及单位、属性</li><li>精确测量光的空间特性</li><li>以正确的物理方式进行光照计算</li></ul><h2 id="一些物理量的定义"><a href="#一些物理量的定义" class="headerlink" title="一些物理量的定义"></a>一些物理量的定义</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>Radiant flux还可以这样理解：假设前面有一个感光的平面，那么单位时间照射到这个平面的光线的强度<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167105002431.png" alt="在这里插入图片描述"></p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167105002442.png" alt="在这里插入图片描述"></p><h2 id="Radiant-Intensity（辐射强度）"><a href="#Radiant-Intensity（辐射强度）" class="headerlink" title="Radiant Intensity（辐射强度）"></a>Radiant Intensity（辐射强度）</h2><p>Radiant Intensity指每个单位立体角上的能量（power）</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167105002443.png" alt="在这里插入图片描述"></p><h2 id="立体角（Solid-Angles）"><a href="#立体角（Solid-Angles）" class="headerlink" title="立体角（Solid Angles）"></a>立体角（Solid Angles）</h2><p>用弧度来表示一个角：<br>弧度：θ&#x3D;l&#x2F;r<br>一个圆的弧度：2π<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_11,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>立体角：<br>立体角就是弧度在三维空间的衍生，在三维空间中，从球心出发，射向球面，会形成一个锥体，然后用球面的面积A除以r^2^</p><p>一个球的立体角是4π<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167105002454.png" alt="在这里插入图片描述"></p><h2 id="单位立体角"><a href="#单位立体角" class="headerlink" title="单位立体角"></a>单位立体角</h2><p>单位立体角就是单位面积然后除以r^2^<br>θ：表示经度方向的角度<br>Φ：表示纬度方向的角度<br>dA：单位面积</p><p>单位立体角：dω&#x3D;dA&#x2F;r^2^&#x3D;sinθ dθ dΦ<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167105002455.png" alt="在这里插入图片描述"><br>对于一个球，所有的单位面积的积分为：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167105002456.png" alt="在这里插入图片描述"><br>辐射度量中，表示三维空间中的方向通常使用ω（单位立体角）</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167105002467.png" alt="在这里插入图片描述"><br>知道了单位立体角，那么Radiant Intensity还可以从另一个角度进行理解。</p><p>Radiant Intensity其实就是这个光源在单位立体角上的能量，我们对所有方向进行积分，可以得到power<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/c65147a15d3c4d289b738f6f13f88cad.png" alt="在这里插入图片描述"><br>Radiant Intensity其实就是power除以4π<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/7f5aa253c27c401b8b5beb18d717d85b.png" alt="在这里插入图片描述"></p><h2 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h2><p>Irradiance是指物体表面单位面积上接收的能量</p><p>lux表示Irradiance的单位<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167105002468.png" alt="在这里插入图片描述"><br>这里的Irradiance必须是垂直于光线的面积，或者说投影到垂直方向上的面积<br>比如向下面这种情况：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/d5e22c7c6cca49109909a3c6df678c59.png" alt="在这里插入图片描述"><br>如果是下面这种情况，物体是倾斜的那么它接收光线的面积其实是投影到垂直方向后的面积，即红色部分<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/4abbb88281064d25ab4782b598e96a83.png" alt="在这里插入图片描述"></p><h2 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h2><p>描述光在传播过程中的属性<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>Radiance是一个表面在单位立体角，单位投影面积的情况下接收的功率，</p><p>一个面的大小和辐射能量的方向是不固定的，我们要研究往一个方向辐射的能量就要确定这个面的大小和辐射方向。所以要结合两者，定义了某一个确定的微小的面dA，和某一个确定的方向dw</p><p>方向就用单位立体角dw来表示<br>面积就用单位面积dA来表示</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167105002479.png" alt="在这里插入图片描述"></p><h2 id="Radiance和Irradiance、Intensity的联系"><a href="#Radiance和Irradiance、Intensity的联系" class="headerlink" title="Radiance和Irradiance、Intensity的联系"></a>Radiance和Irradiance、Intensity的联系</h2><ul><li>Irradiance：物体单位面积上接收的能量</li><li>Intensity：单位立体角上接收的能量</li></ul><p>由上述定义可知：</p><ul><li>Radiance：是Irradiance在单位立体角上的能量</li><li>Radiance：是Intensity在单位面积上的能量</li></ul><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024710.png" alt="在这里插入图片描述"></p><h2 id="Radiance：是Irradiance在单位立体角上的能量"><a href="#Radiance：是Irradiance在单位立体角上的能量" class="headerlink" title="Radiance：是Irradiance在单位立体角上的能量"></a>Radiance：是Irradiance在单位立体角上的能量</h2><p>这里理解成某一个确定微小面积上受到的所有能量（Irradiance），在一个方向ω上的分量<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="Radiance：是Intensity在单位面积上的能量"><a href="#Radiance：是Intensity在单位面积上的能量" class="headerlink" title="Radiance：是Intensity在单位面积上的能量"></a>Radiance：是Intensity在单位面积上的能量</h2><p>这里理解成一个确定的方向上辐射出来的所有能量（I），在一个微小面积上的分量。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024811.png" alt="在这里插入图片描述"></p><h2 id="Irradiance和Radiance比较"><a href="#Irradiance和Radiance比较" class="headerlink" title="Irradiance和Radiance比较"></a>Irradiance和Radiance比较</h2><p>Irradiance：单位面积上所有方向接收的能量<br>Radiance：在单位面积上来自某一个方向的能量<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024812.png" alt="在这里插入图片描述"></p><h2 id="双向辐射分布函数-Bidirectional-Reflectance-Distribution-Function-简称BRDF"><a href="#双向辐射分布函数-Bidirectional-Reflectance-Distribution-Function-简称BRDF" class="headerlink" title="双向辐射分布函数 (Bidirectional Reflectance Distribution Function 简称BRDF)"></a>双向辐射分布函数 (Bidirectional Reflectance Distribution Function 简称BRDF)</h2><p>理解了前面的三个概念之后就可以重新定义反射的概念了。</p><p>反射可以理解为从某个方向进来然后反射到某个方向去的能量。可以用BRDF（反射方程）来描述这个过程。</p><p>就考虑某一个微小面积dA从某各微笑立体角dw接收到的Irradiance，会被如何分配到各个不同的立体角上面去。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024813.png" alt="在这里插入图片描述"><br>BRDF就是 在微小面积dA，从某一个微小立体角dω<del>i</del>，接收到的Irradiance，会如何被分配到各个不同的立体角上去，算的是一个比例。</p><p>对于任何一个出射方向，算出其Radiance的微分，除以Irradiance的微分，这就是BRDF的定义。</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024814.png" alt="在这里插入图片描述"><br>以某一个方向为例，然后我认为某一个着色点可以接收来自四面八方不同的光照，那么对于每一个入射方向，都会对应一个“入射方向→着色点→出射方向”这样的一个BRDF，那么我们就可以把每一个方向上dω的入射光的强度Radiance乘以cosθ乘以BRDF，然后把每一个入射方向上对出射方向的贡献都加起来，就得到了从反射方向看过去这个点的样子了<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024815.png" alt="在这里插入图片描述"><br>反射方程表明了光线到达着色点后被发射的光线属性。但是哪些光线可以到达着色点呢？<br>到达着色点的光线可以是光源发出的光线以及其他着色点反射的光线，所以任何出射的Radiance都可以作为其他着色点入射的Radiance，所以这是一个递归的过程。</p><h2 id="渲染方程（Rendering-Equation）"><a href="#渲染方程（Rendering-Equation）" class="headerlink" title="渲染方程（Rendering Equation）"></a>渲染方程（Rendering Equation）</h2><p>一个物体的光线照射到物体后经过BRDF反射的光线是L<del>r</del>(p,ω<del>r</del>)<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/6155ac11236f4e739f4fe8991615010d.png" alt="在这里插入图片描述"><br>渲染方程：假如物体是一个自发光的物体，则直接把发出的光线加上就行</p><p>渲染方程将一个物体的出射光线分成两部分构成：</p><ul><li>自己发射出去的光</li><li>通过其他光源射入的，经过反射后的光</li></ul><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/85d3b0b7575b439e9cbbef26aecaf73a.png"></p><h2 id="理解渲染方程"><a href="#理解渲染方程" class="headerlink" title="理解渲染方程"></a>理解渲染方程</h2><p>对于只有一个点光源的情况<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024916.png" alt="在这里插入图片描述"><br>对于有多个点光源的情况<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024917.png" alt="在这里插入图片描述"><br>对于有面光源的情况，可以将一个面光源理解为由一堆点光源组成。只需要对面光源所有点发出的光进行积分即可，如果光不是由光源发出的，而是别的物体反射来的，则只需要将别的物体看作光源就行。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024918.png" alt="在这里插入图片描述"><br>我们不知道反射光的Radiance是多少，同时也不知道从其他物体反射过来的光的Radiance是多少，其他白色部分是知道的。</p><p>上面的是原式，下面的是简写<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024919.png" alt="在这里插入图片描述"><br>渲染方程最终可以写成下面的形式：<br>对于所有物体辐射出来的所有能量（L）可以写成 所有光源本身辐射出来的能量（E）加上 辐射出来的能量被反射之后的能量（KL）。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024920.png" alt="在这里插入图片描述"></p><p>写成这个形式是为了解出L<br>写成这种形式后就可以使用用泰勒展开，将其展开成I+K+K^2^+K^3^……<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024921.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050024922.png" alt="在这里插入图片描述"><br>如果光线一次都不弹射直接打到人的眼睛里，那么看到的就是光源E；如果光线弹射一次后打到人的眼睛里，看到的就是直接光照KE（包括阴影）；如果弹射两次，看到的就是间接光照；如果弹射多次就是间接光照的叠加。反射本身就是一种间接光照。</p><h2 id="从光栅化可以做什么的角度来理解该公式"><a href="#从光栅化可以做什么的角度来理解该公式" class="headerlink" title="从光栅化可以做什么的角度来理解该公式"></a>从光栅化可以做什么的角度来理解该公式</h2><p>光栅化可以把物体投影到屏幕上，着色的工作对于的这里的直接光照。</p><p>光栅化能够告诉我们光线传播的内容只有0次（E）和一次（KE）的弹射，后面的部分光栅化比较难完成。因为光线追踪后面的部分比较容易，这就是为什么要用光线追踪来解决光照的问题<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050025023.png" alt="在这里插入图片描述"></p><h2 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h2><p>光线弹射一次，就是直接光照；如果弹射两次，看到的就是间接光照。全局光照就是将光线弹射1次到n次所有的结果全部加起来。</p><p>全局光照是直接和间接光照的集合。</p><h2 id="直接光照和间接光照的影响"><a href="#直接光照和间接光照的影响" class="headerlink" title="直接光照和间接光照的影响"></a>直接光照和间接光照的影响</h2><p>这张图片只渲染了直接光照，也就是光源可以照到的地方是有颜色的，照不到的地方是黑色<br><img src="https://img-blog.csdnimg.cn/86eca8eccd57452e9b17f5b5ee988188.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>直接光照 加上 弹射一次间接光照的结果<br><img src="https://img-blog.csdnimg.cn/ceaaecd7d1a140df8d33c96c17a49aa8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>直接光照 加上弹射一次、两次和三次间接光照的结果<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050025026.png" alt="在这里插入图片描述"><br>假设做无限次的光的弹射，那么最后会收敛到某一个亮度，之后就不会再出现剧烈的变化，会基本保持在某个亮度。（能量守恒和单位时间问题）</p><h2 id="概率论基础"><a href="#概率论基础" class="headerlink" title="概率论基础"></a>概率论基础</h2><p>x指随机变量，p指出现某个随机变量的概率<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050025027.png" alt="在这里插入图片描述"><br>所有概率之和等于1<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050025028.png" alt="在这里插入图片描述"><br>数学期望<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050025029.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050025030.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6%E3%80%81%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671050025131.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（十三）光线追踪（加速结构）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="AABB是怎么加速光线追踪的"><a href="#AABB是怎么加速光线追踪的" class="headerlink" title="AABB是怎么加速光线追踪的"></a>AABB是怎么加速光线追踪的</h2><ul><li>网格划分（Uniform grids）</li><li>空间划分（Spatial partitions）</li></ul><h2 id="网格划分（Uniform-grids）"><a href="#网格划分（Uniform-grids）" class="headerlink" title="网格划分（Uniform grids）"></a>网格划分（Uniform grids）</h2><p>1、找出包围盒<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>2、划分网格<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167104210391.png" alt="在这里插入图片描述"><br>3、找到有物体的格子<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167104210392.png" alt="在这里插入图片描述"><br>假设光线和格子求交是很快的，和物体求交很慢</p><p>这个时候有一条光线穿过这个包围盒，光线穿过的格子为蓝色。当光线走到一个有物体的格子就说明光线可能和物体相交，这个时候就需要求光线和物体是否相交了。其中深蓝色的格子就是光线和物体相交了。</p><p>这样做就避免了执行很多次光线和物体求交，改为执行光线各格子求交。光线和格子求交是很快的，所以加速了光线追踪的速度。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167104210403.png" alt="在这里插入图片描述"></p><h2 id="怎么划分格子的大小"><a href="#怎么划分格子的大小" class="headerlink" title="怎么划分格子的大小"></a>怎么划分格子的大小</h2><p>当格子太稀疏无法确定哪些地方没有物体，哪些地方有物体，这样就需要做很多次光线和物体的求交，则实际上没有太大效果。</p><p>当格子太稠密，检测次数变多，效率也会降低</p><p>应该划分的格子数量：<br>C：表示某一个常数<br>cells：表示格子的总数量<br>objs：表示物体数量</p><p>C在三维平面里根据经验一般取值为 27<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167104210404.png" alt="在这里插入图片描述"></p><h2 id="空间划分（Spatial-partitions）"><a href="#空间划分（Spatial-partitions）" class="headerlink" title="空间划分（Spatial partitions）"></a>空间划分（Spatial partitions）</h2><p>当场景中的物体分布比较均匀时，网格划分的效果很好<br>当场景中的物体分布不均匀时，网格划分的效果就不太行，那么就要用到空间划分了。</p><p>一个真实的场景中经常有一大块的空白区域，这一大块空白其实可一用一个大格子来覆盖，而其他物体稠密的区域仍然用小格子。</p><p>Oct-Tree：八叉树，对于三维空间中的一个场景将其横竖切三刀，切成八块，在二维空间表现为四叉。它的意思就是把包围盒切成四块，然后对于每一个子节点在切成四块，当格子是空的或者格子里面物体足够少时就停止。但是对于高维空间不好划分。</p><p>KD-Tree：类似二叉树，每次将包围盒分成两份，每次都是沿着某个轴的方向进行分割，并且分割顺序是x-&gt;y-&gt;z -&gt;x-&gt;y-&gt;z……这样循环往复。</p><p>BSP-Tree：也是每次划分选择一个方向将空间分成两部分，与KD-Tree相比它不是横平竖直的划分，不好计算。</p><h2 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h2><p>在做光线追踪前需要把KD-Tree划分好然后进行光线追踪</p><p>假设A是一个场景，全部在这个包围盒里。然后进行第一次垂直划分（蓝色和绿色）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167104210405.png" alt="在这里插入图片描述"><br>接下来进行第二次横向划分（绿色和黄色）。蓝色部分实际上也要做划分，这里并不进行演示。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167104210406.png" alt="在这里插入图片描述"><br>然后在黄色部分进行垂直划分，最后再进行横向划分即可得到下面的图形。</p><p>可以发现这样就得到了一颗二叉树，叶子节点存放格子的序号。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167104210407.png" alt="在这里插入图片描述"><br>建立好这个结构后就可以做光线追踪的加速了。</p><h2 id="KD-Tree在实际中是怎么加速的"><a href="#KD-Tree在实际中是怎么加速的" class="headerlink" title="KD-Tree在实际中是怎么加速的"></a>KD-Tree在实际中是怎么加速的</h2><p>首先检查光线和场景中最大的包围盒A是否有交点<img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167104210408.png" alt="在这里插入图片描述"><br>如果有交点则检查光线和左子树是否有交点，当找到一个叶子节点时，那么就和该叶子节点里面的物体求交。（这里1号节点是叶子节点当到达这个节点，那么就要和这个节点里面的物体求交）</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167104210419.png" alt="在这里插入图片描述"><br>接下来光线经过了2号区域那么需要和2号区域里面的物体求交，光线又经过了3号区域那么也要和3号区域里面的物体进行求交。t<del>hit</del>表示光线和最近的物体相交了。</p><p>可以发现4号区域和5号区域光线没有经过，所以不要和里面的物体进行求交，加速了计算速度。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671042104110.png" alt="在这里插入图片描述"><br>KD-Tree也有很多缺点：</p><ul><li>对于有一个三角形构成的场景中，很难判定一个三角形和包围盒有交集</li><li>一个包围盒被划分成了很多个小格子后，一个物体可能会在多个格子里，那么在这些格子都要保存这个物体，最后判断这个物体和光线是否相交也要执行很多次。</li></ul><h2 id="层次包围盒Bounding-Volume-Hierarchy（BVH）"><a href="#层次包围盒Bounding-Volume-Hierarchy（BVH）" class="headerlink" title="层次包围盒Bounding Volume Hierarchy（BVH）"></a>层次包围盒Bounding Volume Hierarchy（BVH）</h2><p>之前的方法都是按照空间来划分的，这个是按照物体划分的。</p><p>这个方法现在广泛应用在光线追踪中</p><h2 id="BVH的实现步骤"><a href="#BVH的实现步骤" class="headerlink" title="BVH的实现步骤"></a>BVH的实现步骤</h2><p>有一个场景 如下<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671042104111.png" alt="在这里插入图片描述"><br>然后将这个场景这个打的包围盒，划分成两部分，然后重新求这两部分的包围盒。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671042104112.png" alt="在这里插入图片描述"><br>然后再对蓝色部分重新划分成蓝色和绿色，再次求包围盒<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671042104113.png" alt="在这里插入图片描述"><br>KD-Tree是先将盒子分成两部分，然后再考虑物体和盒子的相交情况。<br>BVH是物体分成两部分，然后再重新求包围盒，当叶子节点里三角形数量足够少时停止。</p><p>这么做BVH就有一个优点：一个物体只会出现在一个盒子里。 避免了和同一个物体多次求交</p><p>但是BVH对空间的划分可能会重叠，找到一个重叠少的划分方法，也可以提高效率</p><h2 id="划分的依据"><a href="#划分的依据" class="headerlink" title="划分的依据"></a>划分的依据</h2><ul><li>为了让包围盒（节点）在空间中均匀分布，每一次都只沿着最长的轴将其划分。</li><li>在一个节点里划分的时候取一个包围盒中间的物体，（每个三角形都有一个序号，取序号为n&#x2F;2的三角形）这样分成两部分后，这两部分里面的三角形数量差不多相同，也就是要构造一个平衡二叉树</li></ul><h2 id="BVH伪代码"><a href="#BVH伪代码" class="headerlink" title="BVH伪代码"></a>BVH伪代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Intersect(Ray ray, BVH node) &#123;<br> <span class="hljs-keyword">if</span> (ray misses node.bbox) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//光线和包围盒不相交</span><br> <span class="hljs-keyword">if</span> (node is a leaf node)<span class="hljs-comment">//该节点时叶子节点</span><br> test intersection with all objs;<span class="hljs-comment">//测试光线和该节点里面的所有物体是否相交</span><br> <span class="hljs-keyword">return</span> closest intersection;<span class="hljs-comment">//返回最近的交点</span><br> hit1 = Intersect(ray, node.child1);<span class="hljs-comment">//递归左子树</span><br> hit2 = Intersect(ray, node.child2);<span class="hljs-comment">//递归右子树</span><br> <span class="hljs-keyword">return</span> the closer of hit1, hit2;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（十二）光线追踪（基本原理）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="我们是怎么解决阴影问题？"><a href="#我们是怎么解决阴影问题？" class="headerlink" title="我们是怎么解决阴影问题？"></a>我们是怎么解决阴影问题？</h2><p>当对物体着色的时候，只考虑了像素点自己，没有考虑物体遮挡。所以着色不能解决阴影。那么怎么解决阴影问题呢？</p><h2 id="阴影映射（Shadow-mapping）"><a href="#阴影映射（Shadow-mapping）" class="headerlink" title="阴影映射（Shadow mapping）"></a>阴影映射（Shadow mapping）</h2><p>可以使用阴影映射来渲染阴影。阴影映射的实质还是光栅化。<br>阴影映射的思想：<br>如果一个点不在阴影里，则我们可以看到这个点，而且相对于光源来说也可以看到这个点。如果一个点在阴影里，则我们可以看到这个点，但是相对于光源来说也看不到这个点。即一个点不在阴影里面则两者都可以看到。（这种阴影叫做硬阴影）</p><p>实现阴影映射的步骤：<br>1、从光源看向场景记录看到的深度信息。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>2、从摄像机看向这个场景也会得到一个深度信息，然后将两个深度学习进行比较，如果同一个点的两个深度信息是一致的则说明这个点不在阴影内。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167103285921.png" alt="在这里插入图片描述"><br>如果一个点的两个深度信息不一致，说明这个点光源看不到，这点在阴影里面。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167103285922.png" alt="在这里插入图片描述"></p><h2 id="Shadow-mapping的实际过程"><a href="#Shadow-mapping的实际过程" class="headerlink" title="Shadow mapping的实际过程"></a>Shadow mapping的实际过程</h2><p>从光源看过去看到的场景如下<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167103285923.png" alt="在这里插入图片描述"><br>记录深度信息（Shadow mapping）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167103285934.png" alt="在这里插入图片描述"><br>然后从摄像机的出发的得到下面这张图<br>对于这张图，每一个像素对于的实际位置都投影回光源生成的Shadow mapping上，然后对比在Shadow mapping上的深度信息和实际的深度信息，如果是一样的则说明不在阴影里，不一样说明在阴影里。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_17,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p>阴影质量：通常指Shadow mapping的分辨率的高低</p><p>硬阴影：阴影的边缘非常锐利<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_10,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>软阴影：阴影的边缘呈现一种过渡状态（越靠近物体则阴影越硬，离物体越远阴影越软）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/e5ea5f8b92ea4108ad98e60207f1f11d.png" alt="在这里插入图片描述"><br>Umbra:本影<br>Penumbra：半影<br>软阴影就是本影和半影的结合。<br>对于点光源是不会有软阴影的，有软阴影则说明光源有大小。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="为什么要用光线追踪（Ray-tracing）？"><a href="#为什么要用光线追踪（Ray-tracing）？" class="headerlink" title="为什么要用光线追踪（Ray tracing）？"></a>为什么要用光线追踪（Ray tracing）？</h2><p>光栅化不能很好的解决全局效果。<br>一个是对于软阴影光栅化不能很好的解决，另一个是当光线不只反射一次时也很难解决</p><p>用光栅化或者光线追踪渲染阴影的优缺点：<br>光栅化速度很快，但是质量较低。<br>光线追踪光照效果很精确，但是速度慢</p><h2 id="关于光线的定义"><a href="#关于光线的定义" class="headerlink" title="关于光线的定义"></a>关于光线的定义</h2><p>1、光线是沿着直线传播的<br>2、光线交叉不会发送碰撞<br>3、光线是从光源出发到达人眼的，而且光路是可以反转的（从人眼到光源）这叫做光线的可逆性</p><p>光线追踪利用的就是光线的可逆性，从摄像机出发，对于每一个像素发射光线，然后光线会打到场景中某一个位置，然后将这个位置作为起点和光源连起来，如果连线没有被物体遮挡则说明光源也可以照到这个位置，这就找到了一条有效的光路。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167103285935.png" alt="在这里插入图片描述"><br>实现光线最终的具体过程：<br>首先发射光线求得光线和场景最近的交汇点。</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167103285936.png"><br>然后将这个交汇点作为起点和光源连起来，如果连线没有被物体遮挡则说明光源也可以照到这个位置。进行着色以后就只要写回到像素点即可。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167103285947.png" alt="在这里插入图片描述"><br>但在这样计算出来的光线仍然只能模拟光线反射一次，没办法模拟多次弹射</p><h2 id="Whitted-Style光线追踪"><a href="#Whitted-Style光线追踪" class="headerlink" title="Whitted-Style光线追踪"></a>Whitted-Style光线追踪</h2><p>Whitted-Style光线追踪的实现步骤：<br>1、从摄像机出发，对每个像素发射光线<br>Whitted-Style光线追踪就是在任意一个点可以继续传播光线，只需要我们计算出来折射方向即可<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167103285948.png" alt="在这里插入图片描述"><br>2、然后对每个发射了弹射的点都和光源连一条线，计算是否可以被光源照亮。然后对这些点进行着色，并且将所有的着色结果加到该像素上面。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167103285949.png" alt="在这里插入图片描述"><br>对于不同的光线的定义：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859410.png" alt="在这里插入图片描述"></p><h2 id="怎么求光线和物体的交汇点"><a href="#怎么求光线和物体的交汇点" class="headerlink" title="怎么求光线和物体的交汇点"></a>怎么求光线和物体的交汇点</h2><p>光线在数学上的定义<br>光线上的任何一个点都可以用 r(t)&#x3D;0+td 表示,其中的t表示光线传播的时间，td表示光线沿着这个方向传播的距离<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859411.png" alt="在这里插入图片描述"><br>接下来就要求光线和物体的交汇点了，球的方程是  p：（p-c）^2^-R^2^&#x3D;0。如果两者相交，则说明p点即在光线上又在球上。所以只需要将光线的方程带入球的方程即可。即(0+td-c)^2^-R^2^&#x3D;0<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859412.png" alt="在这里插入图片描述"><br>怎么求t<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859413.png" alt="在这里插入图片描述"><br>求光线和一般性的隐式表面的焦点<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859514.png" alt="在这里插入图片描述"></p><h2 id="求光线和显式表面的焦点"><a href="#求光线和显式表面的焦点" class="headerlink" title="求光线和显式表面的焦点"></a>求光线和显式表面的焦点</h2><p>因为模型都是由很多个三角形组成的，要求光线和一个显示表面的焦点只需要把表面上所有三角形和光线的焦点求出来即可。所以求光线和显式表面的焦点主要解决光线和三角形的焦点问题</p><p>通过光线和三角形求焦点还可以判断某一个点是在物体内还是外面。</p><p>假如有一个正方体，在正方体内部的点朝一个方向发射一条光线（射线），发现光线和正方体的焦点是奇数个。在正方体外部的点朝正方体发射一条光线，发现光线和正方体的焦点是偶数个。如下图<img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_11,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="怎么求光线和三角形的焦点"><a href="#怎么求光线和三角形的焦点" class="headerlink" title="怎么求光线和三角形的焦点"></a>怎么求光线和三角形的焦点</h2><p>步骤：<br>1、首先求光线和三角形所在平面的焦点<br>2、判断这个焦点是否在三角形内<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="平面的定义"><a href="#平面的定义" class="headerlink" title="平面的定义"></a>平面的定义</h2><p>平面上的任何一个点p都可以表示为（p-p’）点乘 N&#x3D; 0，因为N是平面的法向量所以平面内的任何一条线都和N垂直，p-p’就表示以p‘作为起点p为终点的一条线。该平面的一般方程为ax+by+cz+d&#x3D;0<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859515.png" alt="在这里插入图片描述"><br>要求光线和平面的焦点，说明这个点即在平面上又在光线上。所以只需要将光线方程代入平面方程即可。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859516.png" alt="在这里插入图片描述"><br>接下来只需要判断点是否在三角形内即可。判断点是否在三角形内位于 计算机图形学GAMES101（一）。</p><h2 id="Moller-Trumbore-Algorithm"><a href="#Moller-Trumbore-Algorithm" class="headerlink" title="Möller Trumbore Algorithm"></a>Möller Trumbore Algorithm</h2><p>上述的方法，首先要求光线和平面的焦点然后还要求点和三角形的位置关系，太麻烦了。</p><p>新方法：MT方法可以直接求光线和三角形的焦点</p><p>（1-b<del>1</del>-b<del>2</del>）$\vec P$<del>0</del>+b<del>1</del>$\vec P$<del>1</del>+b<del>2</del>$\vec P$<del>2</del>表示在三角形内部的点，$\vec O$+t$\vec D$表示光线上的点，它们的焦点肯定是同时满足这两个方程的，所以只需要将这两个方程联立起来即可。<br>这样就只有t、b<del>1</del>、b<del>2</del>是未知数了，求解的过程如下图。</p><p>（重心坐标相关知识位于计算机图形学GAMES101（八））<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859517.png" alt="在这里插入图片描述"><br>一个场景里面有很多物体，一个物体的又是由很多三角形组成的，光线和物体所有的三角形求焦点太慢了，需要一个方法来加速这个过程。</p><h2 id="包围盒（Bounding-Volumes）"><a href="#包围盒（Bounding-Volumes）" class="headerlink" title="包围盒（Bounding Volumes）"></a>包围盒（Bounding Volumes）</h2><p>有一个复杂的物体，我们可以用一个相对简单的形状包起来，这个形状叫做包围盒。如果一束光线跟包围盒都没有焦点，那么跟包围盒里面的物体就更不可能有焦点了。这样就减少了计算量。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859518.png" alt="在这里插入图片描述"><br>对于三维物体一般用长方体来当作包围盒。一个长方体可以理解为是三个不同的对立面形成的交集。</p><p>为什么要这么理解？</p><p>因为平常使用的包围盒叫做轴对齐包围盒（Axis-Aligned Bounding Box）缩写：AABB。这个长方体的任意一条边都和某一条轴（x、y、z轴）是平行的。在二维平面上就是对于一个长方形，这个长方形的边都是和轴对齐的。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="二维平面上光线和包围盒求焦点"><a href="#二维平面上光线和包围盒求焦点" class="headerlink" title="二维平面上光线和包围盒求焦点"></a>二维平面上光线和包围盒求焦点</h2><p>在二维情况下，包围盒的两个对立面就变为了两条竖线。我们只需要算出光线什么时候和X<del>0</del>相交，什么时候和X<del>1</del>相交，就可以算出光线在x方向和包围盒相交的点了。在t<del>min</del>时刻进入了包围盒的对立面，在t<del>max</del>时刻离开包围盒的对立面。（如下面左图）</p><p>光线与y方向的判断同理（如下面中图）。</p><p>刚刚分别得到了x方向和y方向的进入、离开时刻，那么如何得到光线进入、离开整个盒子的时刻呢？</p><p>只需要求两端线段的交集（如下面右图）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859619.png" alt="在这里插入图片描述"></p><h2 id="三维平面上光线和包围盒求焦点"><a href="#三维平面上光线和包围盒求焦点" class="headerlink" title="三维平面上光线和包围盒求焦点"></a>三维平面上光线和包围盒求焦点</h2><p>三维情况下一个包围盒有三个对立面。</p><p>光线进入所有对面（三个对面）的时候，才可以说明光线进入这个盒子，而当光线离开任意一个对面的时候，就可以说明光线离开了这个盒子。</p><p>对于一个三维的包围盒，有三个不同的对立面，各计算一次光线进入对立面的最小时间t<del>min</del>和最大时间t<del>max</del>。由于光线进入所有对面（三个对面）的时候，才可以说明光线进入这个盒子，那么计算出光线进入盒子的时间就是t<del>min</del>中最大的，即为t<del>enter</del>，也就是光线最晚进入的那一组对面的时间。同理，由于光线离开一个对面的时候，就可以判定光线离开这个盒子，那么光线离开离开这个盒子就是t<del>max</del>中最小的，也就是光线最早离开的那一组对面的时间，即为t<del>exit</del>。</p><p>这样就得到了光线什么时候进入的盒子以及什么时候离开的盒子。</p><p>如果进入的时间小于离开的时间，即t<del>enter</del>&lt;t<del>exit</del>说明这段时间光线就在盒子里，说明光线和盒子有焦点。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859620.png" alt="在这里插入图片描述"></p><p>接下来考虑时间t的正负</p><ul><li>如果离开盒子的时间为负，则说明光线在盒子后面，无交点。</li><li>如果离开盒子的时间为正，而进入盒子的时间为负，则说明光线的起点就在这个盒子里面。一定有交点。</li></ul><p> 总结：<br> 当且仅当进入时间小于离开时间且离开时间非负，则证明有交点。</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671032859621.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（十一）几何（网格处理）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本节涉及内容：</p><ul><li>网格细分（Mesh subdivision）</li><li>网格简化（Mesh simplification）</li><li>网格规则化（Mesh regularization）</li></ul><h2 id="曲面细分"><a href="#曲面细分" class="headerlink" title="曲面细分"></a>曲面细分</h2><p>曲面细分可以使模型的细节更加丰富。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>曲面细分的规则:</p><ul><li>首先创建更多的三角形(顶点)</li><li>其次，调整它们的位置<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167102184921.png" alt="在这里插入图片描述"></li></ul><h2 id="Loop-Subdivision"><a href="#Loop-Subdivision" class="headerlink" title="Loop Subdivision"></a>Loop Subdivision</h2><p>Loop细分是一种三角形网格的细分法则，它按照下图三角形分裂，每条边计算生成一个新的顶点，同时每个更新新顶点&#x2F;原始顶点的位置<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/45ee76560fbd4e6880afd9ed2b452b79.png" alt="在这里插入图片描述"></p><h2 id="怎么改变新顶点的位置"><a href="#怎么改变新顶点的位置" class="headerlink" title="怎么改变新顶点的位置"></a>怎么改变新顶点的位置</h2><p>其中白色的顶点是会被两个三角形所共享，将共享顶点所在的这条公共边两端的两个公共顶点分别定义为A、B，然后把这两个三角形非公共的两个顶点分别定义为C、D。<br> 因为A、B顶点离白点交近所以影响较大，C、D顶点离白点交远所以影响较小。所以新顶点的位置&#x3D;3&#x2F;8*(A+B)+1&#x2F;8*(C+D)。（加权平均）<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167102184932.png" alt="在这里插入图片描述"></p><h2 id="怎么改变旧顶点的位置"><a href="#怎么改变旧顶点的位置" class="headerlink" title="怎么改变旧顶点的位置"></a>怎么改变旧顶点的位置</h2><p>对于一个老顶点（中间的白色顶点），它周围的老顶点会对其位置产生影响。那么就需要综合考虑周围老顶点的位置信息和该顶点自身的位置信息。</p><p>n表示顶点的度（连接的边的数量）<br>u代表比率系数<br>老顶点的位置&#x3D;(1 - n*u) * original_position + u * neighbor_position_sum<br>通过这个公式可以发现n当越大时，代表连接的三角形越多那么自身的位置影响就很小，基本就可以由周围的顶点决定位置。<br>反之，n当越小时，代表连接的三角形越少那么周围顶点影响就很小，基本就可以由老顶点自身位置决定。</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167102184933.png" alt="在这里插入图片描述"></p><h2 id="Catmull-Clark-Subdivision-General-Mesh"><a href="#Catmull-Clark-Subdivision-General-Mesh" class="headerlink" title="Catmull-Clark Subdivision (General Mesh)"></a>Catmull-Clark Subdivision (General Mesh)</h2><p>当模型不是由三角形组成时采用Catmull-Clark细分。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167102184944.png" alt="在这里插入图片描述"><br>Catmull-Clark细分步骤:<br>在每个面添加中心点<br>在每条边添加中点<br>连接所有的新顶点  </p><p>可以发现中间的两个点都是奇异点，因为这个点是在三角形内的，因为它要于三角形三边都要连接，所以它的度一定不是4</p><p>经过了这次细分所以的非四边形面都没有了，也就是说经过细分后一个四边形面会增加一个奇异点，并且四边形面会消失。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167102184945.png" alt="在这里插入图片描述"><br>而且在这个基础上再次细分，奇异点不会增加了<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="怎么调整顶点的位置"><a href="#怎么调整顶点的位置" class="headerlink" title="怎么调整顶点的位置"></a>怎么调整顶点的位置</h2><p>Catmull-Clark细分将顶点分成三类：<br>1、顶点在面中间（Face point）<br>2、顶点在边的中心点（Edge point）<br>3、以前老的顶点（Vertex point）<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167102184956.png" alt="在这里插入图片描述"><br>Loop细分和Catmull-Clark细分对比：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167102184957.png" alt="在这里插入图片描述"></p><h2 id="曲面简化"><a href="#曲面简化" class="headerlink" title="曲面简化"></a>曲面简化</h2><p>在一个很复杂的模型的基础上进行简化（删除一部分三角形）使其保留原始轮廓，达到节省资源的目的。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167102184958.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167102184959.png" alt="在这里插入图片描述"></p><h2 id="边坍缩（edge-collapsing）"><a href="#边坍缩（edge-collapsing）" class="headerlink" title="边坍缩（edge collapsing）"></a>边坍缩（edge collapsing）</h2><p>方法：首先找到一条边的两个顶点然后将这个两个顶点合拢成一个点。<img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671021849610.png" alt="在这里插入图片描述"></p><h2 id="⼆次误差度量（Quadric-Error-Metrics）"><a href="#⼆次误差度量（Quadric-Error-Metrics）" class="headerlink" title="⼆次误差度量（Quadric Error Metrics）"></a>⼆次误差度量（Quadric Error Metrics）</h2><p>二次误差度量可以找到哪些边应该被坍缩，哪些应该被保留<br>二次误差度量的概念：<br>希望找到一个位置，使得这个点和它相关联的面的距离的平方和最小。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671021849611.png" alt="在这里插入图片描述"><br>怎么去坍缩？<br>对于整个模型，首先去坍缩每一条边，然后计算二次误差度量。然后将二次误差度量的值升序排列，进行边坍缩时只需要从最小的开始坍缩，并且因为坍缩之后其他边也会受到牵连，所以又要再次计算二次误差度量，然后再取最小的进行坍缩。</p><h2 id="曲面规则化"><a href="#曲面规则化" class="headerlink" title="曲面规则化"></a>曲面规则化</h2><p>原模型的三角形是不规则的，网格规则化就是把三角形变成正三角形。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E7%BD%91%E6%A0%BC%E5%A4%84%E7%90%86%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671021849612.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（十）几何（曲线与曲面）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="显示几何"><a href="#显示几何" class="headerlink" title="显示几何"></a>显示几何</h2><p>显示几何的表示方法：</p><ol><li>点云（Point Cloud）<br>不把一个物体的表面用平面来表示，而是用很密集的点来表示。当点足够多时就可以表示一个平面。通常用在扫描中<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_14,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></li><li>多边形网格（Polygon Mesh）</li></ol><p> 存储顶点和多边形(通常是三角形或四边形)<br> 更容易处理&#x2F;模拟<br> 自适应采样更复杂的数据结构<br> 图形中最常见的表示方式<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="曲线（Curves）"><a href="#曲线（Curves）" class="headerlink" title="曲线（Curves）"></a>曲线（Curves）</h2><ol><li>⻉塞尔曲线（Bézier Curves）<br>P<del>0</del>为起始点，P<del>3</del>为终止点，P<del>1</del>，P<del>2</del>为控制点，蓝的的线为表示的曲线，该曲线要经过起始点和终止点，但是不要求经过控制点。<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167101305221.png" alt="在这里插入图片描述"></li></ol><h2 id="怎么用任意个数的点画出贝塞尔曲线"><a href="#怎么用任意个数的点画出贝塞尔曲线" class="headerlink" title="怎么用任意个数的点画出贝塞尔曲线"></a>怎么用任意个数的点画出贝塞尔曲线</h2><p>德卡斯特里奥算法（de Casteljau Algorithm）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167101305222.png" alt="在这里插入图片描述"></p><p>假设起点在时间0，终点在时间1，要画出这条曲线就是要找出时间t&#x3D;0<del>1时，在空间中对于的点的位置。<br>首先找出t在0到1上的位置（假如时1&#x2F;3）然后将b</del>0<del>看作0，b</del>1<del>看作1，然后在b</del>0<del>b</del>1<del>找到t对应的位置b</del>0<del>^1^，即1&#x2F;3处。<br>同理在b</del>1<del>b</del>2<del>上也找到t相对于的点b</del>1<del>^1^然后将它们连起来。<br>最后在b</del>0<del>^1^b</del>1<del>^1^上找到t对应的点b</del>0<del>^2^。这就是在t时刻对应空间上的点了。找到时间0</del>1上所有的点然后连起来就可以得到曲线了。</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167101305223.png" alt="在这里插入图片描述"><br>多控制点的动态演示：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/36ac2280dbf89c89b19b9aa6089848ed.gif" alt="在这里插入图片描述"></p><h2 id="贝塞尔曲线的代数形式"><a href="#贝塞尔曲线的代数形式" class="headerlink" title="贝塞尔曲线的代数形式"></a>贝塞尔曲线的代数形式</h2><p>b<del>0</del>^2^代数形式的求解过程：<br>可以发现b<del>0</del>^2^(t)&#x3D;[(1-t)+t]^2^的展开式。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167101305234.png" alt="在这里插入图片描述"><br>有n个控制点的展开式可以用下面的多项式描述<br>伯恩斯坦多项式（Bernstein polynomials）：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167101305235.png" alt="在这里插入图片描述"><br>对于三维空间中的曲线，求曲线上的点可以用下面的式子：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167101305236.png" alt="在这里插入图片描述"><br>贝塞尔曲线的性质：</p><ul><li>当t&#x3D;0时。在起点。t&#x3D;1时，在终点、即b(0)&#x3D;b<del>0</del>;b(1)&#x3D;b<del>3</del>。</li><li>当控制点为4个时，起始点和终止点的切线分别是b^’^(0)&#x3D;3(b<del>1</del>-b<del>0</del>);b^’^(1)&#x3D;3(b<del>3</del>-b<del>2</del>)。</li><li>想要对一条贝塞尔曲线做仿射变换，只需要对所有控制点做仿射变换然后重新绘制贝塞尔曲线即可。</li><li>凸包性质：画出来的贝塞尔曲线必需要在控制点形成的凸包内。</li></ul><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167101305247.png" alt="在这里插入图片描述"><br>凸包：<br>假设黑色的圈是被拉大的橡皮筋，然后松手，橡皮筋就会收缩到蓝线位置。蓝线所形成的多边形就是这些顶点的凸包。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167101305248.png" alt="在这里插入图片描述"><br>蓝色的部分是控制点形成的凸包<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167101305249.png" alt="在这里插入图片描述"></p><h2 id="逐段贝塞尔曲线"><a href="#逐段贝塞尔曲线" class="headerlink" title="逐段贝塞尔曲线"></a>逐段贝塞尔曲线</h2><p>因为当控制点过多时，发现贝塞尔曲线并不好控制。<br>所以采用少量控制点来控制一段曲线，最后把所有曲线都连起来就得到了原本的曲线。</p><p>一般采用三次贝塞尔曲线（4个控制点）成为一段。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671013052410.png" alt="在这里插入图片描述"><br>第一段的终点等于第二段的起点这种连续称作C^0^连续。（相对于函数值相等）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671013052411.png" alt="在这里插入图片描述"><br>第一段的终点等于第二段的起点，而且切线也要连续（相对于函数一阶导数相等）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671013052512.png" alt="在这里插入图片描述"></p><h2 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h2><p>贝塞尔曲面<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671013052513.png" alt="在这里插入图片描述"><br>由4*4个控制点的得到的曲面：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671013052514.png" alt="在这里插入图片描述"></p><p>首先对每一列的四个控制点生成一条曲线，然后把得到的四个点又认为是另外一条曲线的控制点，又可以得到一条曲线，该曲线滑动所经过的平面就是贝塞尔曲面。<br><img src="https://img-blog.csdnimg.cn/d8179d7ce77e4ccbb4182020f2aba687.gif" alt="请添加图片描述"><br>具体流程：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671013052515.png" alt="在这里插入图片描述"><br>如何找到贝塞尔曲面上的任何一个点：<br>首先找到四条曲线上时间u的点（对应图片中4个蓝色的点），然后再在蓝色曲线上找时间v所对应的点。所以一个曲面上的点可以用（u，v）来表示。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%8D%81%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E6%9B%B2%E7%BA%BF%E4%B8%8E%E6%9B%B2%E9%9D%A2%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671013052616.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（九）几何（基本表示方法）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本节涉及内容：</p><ul><li>纹理的应用</li><li>几何</li></ul><p>在现代GPU中可以将纹理理解为：<br>纹理&#x3D;内存区域+范围查询（过滤）</p><ul><li>纹理不仅仅可以用作物体的贴图，还可用来记录环境光照。</li></ul><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="凹凸贴图、法线贴图"><a href="#凹凸贴图、法线贴图" class="headerlink" title="凹凸贴图、法线贴图"></a>凹凸贴图、法线贴图</h2><ul><li>纹理还可以用作凹凸贴图，存储高度值。<br> 右边原本是一个球，凹凸贴图其实是保存了三角形任意一个点的相对高度，凹凸贴图可以在不在几何形体变复杂的情况下，应用了一个复杂的纹理，使其相对高度发送变化（法线发送了变化），从而改变着色的结果。由于着色结果发送了变化从而产生了明暗对比，实现了凹凸效果。（球的模型并没有改变）</li></ul><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167100340481.png" alt="在这里插入图片描述"><br>凹凸贴图或者法线贴图的实质是为了改变任意一个点的法线。</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167100340482.png" alt="在这里插入图片描述"></p><h2 id="位移贴图"><a href="#位移贴图" class="headerlink" title="位移贴图"></a>位移贴图</h2><p>位移贴图也是用纹理来改变几何物体表面的相对高度，相对于凹凸贴图，位移贴图会把几何形体表面的三角形顶点位置进行移动。左别凹凸贴图，右边位移贴图。<br>但是要求几何形体表面的三角形足够精细才行。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167100340483.png" alt="在这里插入图片描述"><br>纹理贴图还可以记录一些提前算好的信息，比如模型自己本身互相遮挡产生的阴影<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167100340484.png" alt="在这里插入图片描述"></p><h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><p>分为：<br>Implicit geometry：隐式几何<br>Explicit geometry：显式几何</p><h2 id="隐式几何（Implicit-geometry）"><a href="#隐式几何（Implicit-geometry）" class="headerlink" title="隐式几何（Implicit geometry）"></a>隐式几何（Implicit geometry）</h2><p>表示一些关系，并不会给你实际的点<br>例如表示一个球，会这么表示X^2^+Y^2^+Z^2^&#x3D;1</p><p>更加通用的情况:<br>对于任意一个点，只要满足f(x,y,z)&#x3D;0，就认为这一点是在该表面上的，只要找到这个表面上所有的点就可以得到该表面<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167100340485.png" alt="在这里插入图片描述"></p><h2 id="隐式几何的缺点"><a href="#隐式几何的缺点" class="headerlink" title="隐式几何的缺点"></a>隐式几何的缺点</h2><p>得到一个函数，很难直观的看出来它表示的图形。<br>例如函数<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/c61e937528cd404082ea0fee2d3cb582.png" alt="在这里插入图片描述"><br>它表示的几何图形是<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="隐式几何的优点"><a href="#隐式几何的优点" class="headerlink" title="隐式几何的优点"></a>隐式几何的优点</h2><p>判断一个点在不在这个几何形状上面是很容易的。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167100340496.png" alt="在这里插入图片描述"></p><h2 id="显式几何"><a href="#显式几何" class="headerlink" title="显式几何"></a>显式几何</h2><p>显式几何：把所有点都表示出来，如三角形把面上的点都表示出来。</p><p>另一种显式的方法是通过参数映射。定义一个uv空间，上面有任意一个点用坐标uv表示，对应每一个uv值都可以映射到三维空间上的某一个点，把uv上所有的点都遍历一遍，转换为XYZ的形式，在三维空间中得到一个完整的几何体。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167100340497.png" alt="在这里插入图片描述"></p><h2 id="显式几何的优点"><a href="#显式几何的优点" class="headerlink" title="显式几何的优点"></a>显式几何的优点</h2><p>显示几何的表现形式：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/accb0fa89d674d3d94605738dabce3e4.png" alt="在这里插入图片描述"><br>表示的图形：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167100340498.png" alt="在这里插入图片描述"><br>我们只需要把每一个uv都测试一遍就可以知道表示的几何形状，所以显式几何很容易知道其表示的图形</p><h2 id="显式几何的缺点"><a href="#显式几何的缺点" class="headerlink" title="显式几何的缺点"></a>显式几何的缺点</h2><p>判断一个点是在表面上或者在里面还是外面用显式几何就很难了。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167100340499.png" alt="在这里插入图片描述"></p><h2 id="隐式几何的其他例子"><a href="#隐式几何的其他例子" class="headerlink" title="隐式几何的其他例子"></a>隐式几何的其他例子</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671003404910.png" alt="在这里插入图片描述"></p><ol><li>Constructive Solid Geometry （CSG）：通过一系列几何的基本运算来定义复制的几何。</li></ol><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671003405011.png" alt="在这里插入图片描述"></p><ol start="2"><li>Distance Functions 距离函数<br>对于任何一个几何都不直接去描述它的表面，而去表述任何一个点到这个表面的最近距离。<br>距离函数是指空间中任何一个点到需要表达的几何形体之间的最小距离。如果有一个点在几何形体的外面则距离是正数，如果有一个点在几何形体的里面则计算出最小距离后加一个负号。空间任何一个点都有一个距离值，把这两个物体各自的距离函数都算出来之后，把两个距离函数做一个融合，再把他恢复成原来的物体。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/003e9c10273647f1bc234b11f6e8c199.png" alt="在这里插入图片描述"><br>举例：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671003405012.png" alt="在这里插入图片描述"><br>有AB两张图，A的1&#x2F;3是黑色的，B的2&#x2F;3是黑色的，我们希望的到左边是黑色右边是白色的图。如果我们直接blend（A，B）那么结果是1&#x2F;3黑色（左侧），1&#x2F;3灰色（中间），1&#x2F;3白色（右侧）。</li></ol><p>那么我们就需要使用距离函数SDF（A）来计算每个点到边界的距离，边界的值认为是0，越靠近边界值越接近0，如果点在边界右边则值为正数，如果点在边界左边则值为负数。可以理解为值越小则越黑，值越大则越白，这样就将A变为一个从黑渐变到白色的图片了。</p><p>对B用使用距离函数SDF（B）</p><p>将SDF（A）和SDF（B）做一次blend，然后就可以得到这两张图渐变的中间位置。那么这个blend后的图像中间即为0，向右（白）为正，向左（黑）为负。如果通过SDF回复成原来的形状，就可以知道，0的地方就是他们的边界，非0的地方不是，blend两个对应的SDF，就是在blend它们的边界。</p><p>使用距离函数的示意图：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671003405013.png" alt="在这里插入图片描述"></p><h2 id="水平集方法"><a href="#水平集方法" class="headerlink" title="水平集方法"></a>水平集方法</h2><p>距离函数blend之后得到一个函数，这么样才能恢复成表面呢<br>我们只需要把距离函数f（x）&#x3D;0的位置全部找出来就行了</p><p>水平集方法：<br>水平集方法就是把距离写在不同的格子里面，只需要找到在中间值是0的地方，然后就可以把整个函数试图表示的物体提取出来，类似于地理上的等高线。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_15,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="几何的另一个概念：分形"><a href="#几何的另一个概念：分形" class="headerlink" title="几何的另一个概念：分形"></a>几何的另一个概念：分形</h2><p>分形类似于递归<br>例如雪花是六边形的，放大后每一条边上还有六边形，六边形里面仍然还有六边形。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B9%9D%EF%BC%89%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171671003405014.png" alt="在这里插入图片描述"><br>隐式函数的有点总结：</p><ul><li>描述起来比较简单</li><li>某些查询很容易(对象内部，到表面的距离)</li><li>适合于光线和表面的求交</li><li>对于简单的形状，精确描述&#x2F;无采样误差</li><li>适合用来描述拓扑结构(如流体)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（八）着色（插值、高级纹理映射）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本节内容：</p><ul><li>重心坐标</li><li>纹理的应用</li></ul><h2 id="重心坐标（Barycentric-Coordinates）"><a href="#重心坐标（Barycentric-Coordinates）" class="headerlink" title="重心坐标（Barycentric Coordinates）"></a>重心坐标（Barycentric Coordinates）</h2><p>重心坐标就是为了解决在三角形内部做插值的问题。（插值就是从一个顶点的颜色平滑的过度到另一个顶点的颜色）</p><h2 id="重心坐标的含义"><a href="#重心坐标的含义" class="headerlink" title="重心坐标的含义"></a>重心坐标的含义</h2><p>重心坐标是定义在一个三角形上的，在三角形ABC中的任何一个点（x，y）都可以表示成三角形的顶点ABC的线性组合，并且需要满足α+β+γ&#x3D;1（等于1时是在三角形所在的平面内，不等于1则不在平面内）。这样就可以用（α，β，γ）来表示一个点了。如果α，β，γ都为非负数，则表示这个点在三角形内部<br>这样用的好处：<br>只要知道三个顶点，就可以表示三角形内部任意一个点的位置了<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>顶点自己的坐标：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167099023731.png" alt="在这里插入图片描述"><br>可知A点自己的重心坐标是（1，0，0）</p><h2 id="怎么求重心坐标"><a href="#怎么求重心坐标" class="headerlink" title="怎么求重心坐标"></a>怎么求重心坐标</h2><p>方式一：<br>α的值是和A点不相邻的三角形的面积除以总面积<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167099023732.png" alt="在这里插入图片描述"></p><h2 id="三角形的重心"><a href="#三角形的重心" class="headerlink" title="三角形的重心"></a>三角形的重心</h2><p>三角形的重心把大三角形均匀的分为了三份，所以三角形重心的重心坐标为（1&#x2F;3,1&#x2F;3,1&#x2F;3）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167099023733.png" alt="在这里插入图片描述"></p><h2 id="怎么求重心坐标-1"><a href="#怎么求重心坐标-1" class="headerlink" title="怎么求重心坐标"></a>怎么求重心坐标</h2><p>方式二：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167099023734.png" alt="在这里插入图片描述"></p><h2 id="利用重心坐标来做插值"><a href="#利用重心坐标来做插值" class="headerlink" title="利用重心坐标来做插值"></a>利用重心坐标来做插值</h2><p>直接用属性乘以重心坐标就可以求出三角形内部任意一点插值的结果。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167099023745.png" alt="在这里插入图片描述"></p><h2 id="怎么应用纹理"><a href="#怎么应用纹理" class="headerlink" title="怎么应用纹理"></a>怎么应用纹理</h2><p>屏幕上任何一个采样点都有一个位置，就可以知道在这个位置上插值出来的uv（纹理坐标）。原来的纹理坐标都定义在三角形的顶点上现在对于任何一个三角形内的点，我们都知道其在三角形中的位置，然后用重心坐标做一个插值，可以算出这一个点的uv。<br>然后去纹理上查询一些uv的值就可以得到对应的纹理，（可以用来当作漫反射系数K<del>d</del>）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167099023746.png" alt="在这里插入图片描述"><br> 那么这样应用纹理会带来什么问题</p><h2 id="问题1：分辨率高纹理小"><a href="#问题1：分辨率高纹理小" class="headerlink" title="问题1：分辨率高纹理小"></a>问题1：分辨率高纹理小</h2><p>如果分辨率高（假如是4K），而纹理小（假如是256P），那么在任意一个点上去查纹理，可能会查到一些非整数的值。这样就会造成纹理被拉大</p><p>对应屏幕上任意一个点都可以在纹理上找到一个相应的位置，如果不是整数则采用四舍五入，这样会造成在不同像素上应用的其实是同一个纹理，即图Nearest</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167099023747.png" alt="在这里插入图片描述"></p><p>为了解决用非整数坐标在查询纹理时怎么得到纹理对应得值，引入双线性插值</p><p>可以看到此时红色得点并没有落在纹理的任何一个位置上，而是一个非整数的位置，如果采用四舍五入的方法那么落在一个纹理在周围的正方形里面的像素都会显示用一个颜色，这显然是不对的</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167099023748.png" alt="在这里插入图片描述"><br>双线性插值的做法：<br>首先找到像素临近四个的四个纹理点<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>然后计算红点离左下角u<del>00</del>这个点的水平距离s和插值距离t，s、t都是位于0~1之间（两个纹理像素之间相差1）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_17,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>然后进行线性插值lerp</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/43e68859697a40e18c5a8ae286061bd7.png" alt="在这里插入图片描述"><br>其中v<del>0</del>和v<del>1</del>是两个不同的点，当x&#x3D;0时lerp的值就是v<del>0</del>，当x&#x3D;1时lerp的值就是v<del>1</del>，当x位于0到1之间时lerp的值就是位于v<del>0</del>到v<del>1</del>之间</p><p>这样我们就可以利用 距离s 以及 左下角 和 右下角 的点做一个线性插值来就出u<del>0</del>的颜色，u<del>1</del>同理<img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167099023759.png"><br>然后利用距离t 再对u<del>0</del>，u<del>1</del>做一次插值，这样就求出了红点的颜色了。其颜色取决于周围四个纹理像素的颜色。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237510.png" alt="在这里插入图片描述"><br>双线性插值后的效果：Bilinear<img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237511.png" alt="在这里插入图片描述"></p><h2 id="比双线性插值更高明的方法——双三次插值Bicubic"><a href="#比双线性插值更高明的方法——双三次插值Bicubic" class="headerlink" title="比双线性插值更高明的方法——双三次插值Bicubic"></a>比双线性插值更高明的方法——双三次插值Bicubic</h2><p>这种操作取的是周围16个像素而非4个像素，然后用这16个像素做水平和竖直方向的插值，不过是每次用4个做三次插值。</p><h2 id="问题2：分辨率低纹理大"><a href="#问题2：分辨率低纹理大" class="headerlink" title="问题2：分辨率低纹理大"></a>问题2：分辨率低纹理大</h2><p>当分辨率低而纹理分辨率高时会出现摩尔纹。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237512.png"><br>摩尔纹出现的原因<br>分辨率低就会造成一个像素会覆盖多个纹理。</p><p>在近处时一个像素覆盖纹理上的区域相对交小<br>在远处时一个像素覆盖纹理上的区域相对交大</p><p>当像素覆盖的纹理区域大时就不知道应该应用哪个纹理了，就会造成摩尔纹（走样）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237513.png" alt="在这里插入图片描述"><br>可以看到图片上有很多锯齿，那么肯定也可以用抗锯齿的方法</p><p>解决方法：<br>使用超采样技术后MSAA的效果：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237514.png" alt="在这里插入图片描述"><br>但是花费太高了</p><p>更好的解决方法：<br>点查询：有一个点，然后去纹理上面查找相应的纹理，这是点查询<br>范围查询：不做采样，拿到一个区域立刻可以得到其内部的平均值，这是范围查询（范围查询可以查范围的最大值、最小值、平均值等等）</p><p>我们只要知道纹理上一块区域的平均值，然后使用这个平均值当作该像素的颜色就行了<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237515.png" alt="在这里插入图片描述"></p><h2 id="MipMap"><a href="#MipMap" class="headerlink" title="MipMap"></a>MipMap</h2><p>怎么得到一个范围的值呢？<br>使用MipMap<br>特点：速度快、不一定准确（近似值）、只能查询正方形范围</p><p>MipMap的含义：<br>当我们拿到原始纹理（level 0）时，先把这些MipMap都生成。即每次图片分辨率都缩小一半，直到1*1<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237616.png" alt="在这里插入图片描述"><br>将这些图叠加到一起：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237617.png" alt="在这里插入图片描述"><br>因为每一层图分辨率都缩小一半，所以每一层的存储量都是上一层的四分之一，总开销&#x3D;1+1&#x2F;4+1&#x2F;16+……   计算得总开销是4&#x2F;3，额外开销仅仅是1&#x2F;3。</p><p>任何一个像素都可以映射到一个纹理上的区域，要计算这个区域有多大，首先要把其周围的像素也投影上去<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237618.png" alt="在这里插入图片描述"><br>已知一个像素在屏幕空间上距离是1，那么就可计算出投影到纹理上的距离L，那么我们就可以计算出一个像素在纹理上占据的面积了。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237619.png" alt="在这里插入图片描述"><br>红色部分是映射到纹理上的实际区域，正方形是近似区域。<br>得到这个正方形后就可以根据正方形边长L去查找哪一张图片，从而得到改正方形区域颜色的平均值。<br>当正方形是1<em>1时即L&#x3D;1， 则log<del>2</del>L&#x3D;0，表示可以在原始纹理上找到其对应像素，像素的值就是该区域的平均值<br>当正方形是2</em>2时即L&#x3D;2， 则log<del>2</del>L&#x3D;1，表示在level 1上对应一个像素，像素的值就是该区域的平均值</p><p>边长为L则到log<del>2</del>L层去查找像素。</p><p>下面是不同位置的查询层数，同颜色代表在同一层<img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237620.png" alt="在这里插入图片描述"><br>怎么解决查询第1.5层呢？<br>使用插值的方法就行</p><p>首先找到第一层，然后找D+1层，这两层内部使用双线性插值求出每一层内部的值，然后将求得的两个插值结果在层与层之间再做一次插值。所以一共做了三步，这叫做三线性插值。这就得到了1.5层<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237621.png" alt="在这里插入图片描述"><br>结果三线性插值后查询层数的结果<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237622.png" alt="在这里插入图片描述"><br>使用MipMap之后的图：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_17,color_FFFFFF,t_70,g_se,x_16-171670990237623.png" alt="在这里插入图片描述"><br>可以看到相比MSAA 远处是糊的，因为其只能查询正方形区域的平均值，如果不是正方形就会产生误差，而且插值也会带来误差，误差叠加之下就糊了。</p><p>各向异性过滤（Anisotropic Filtering ） ：在不同的方向上的表现并不相同（考虑不同的方向），是用来过滤、处理当视角变化导致3D物体表面倾斜时造成的纹理错误。</p><p>各向同性过滤 ：在不同的方向上的表现相同（不考虑方向）</p><p>在MipMap的基础上进行各向异性过滤：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_17,color_FFFFFF,t_70,g_se,x_16-171670990237624.png" alt="在这里插入图片描述"></p><p>MipMap所作的工作其实是计算主对角线上的图片，横向压缩和竖向压缩MipMap是没有做的，所以MipMap只能查询正方形区域。</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_11,color_FFFFFF,t_70,g_se,x_16.png"><br>而各向异性过滤做了横向压缩和竖向压缩，所以可以查询矩形区域了，实际中的图片会各种形状，矩形区域更加精准但是仍然不完全准确。其开销是原来三倍<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670990237725.png" alt="在这里插入图片描述"><br>为了解决不能查询不规则的图形问题有一个新方法</p><h2 id="EWA"><a href="#EWA" class="headerlink" title="EWA"></a>EWA</h2><p>EWA滤波被广泛的认为是纹理过滤（texture filtering)算法中最好的算法之一。对于任何一个形状，都可以拆成很多不同的圆形去覆盖这个形状。如上图查询一个椭圆，将其拆成三个圆形，每次去查询一个圆形，多次查询自然就可以得到一个区域，但是代价是“多次查询”。可见质量越高的效果，性能开销越大。</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AB%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_10,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p>各向异性过滤主要靠显存，打游戏现存大可以开。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（七）着色（着色频率、图形管线、纹理映射）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>一个物体的着色工作主要考虑：</p><ul><li>高光</li><li>漫反射</li><li>环境光</li></ul><h2 id="接下来是高光"><a href="#接下来是高光" class="headerlink" title="接下来是高光"></a>接下来是高光</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_15,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>已知 当摄像机的视角越接近R则高光越强。</p><p>Blinn-Phong模型<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p>计算公式：<br>使用l和v两个向量夹角的角平分线h（也叫做半程向量）和法线n的接近程度来计算高光，越接近高光越强。这里的h和n接近一定程度上就反应了上面的v和R接近。n点乘h 表示接近程度，越接近则值越靠近1，如果离得比较远则接近0。这里不考虑有多少光被吸收。</p><p>Phong模型是通过计算过v和R的接近程度来计算高光（计算反射方向R不好算）<br>Blinn-Phong模型是通过计算过h和n的接近程度来计算高光（是Phong模型的改进，半程向量h比较好计算过）</p><p>其中<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/54b0bf67fa9c4ed1909e869f2aa9cee3.png" alt="在这里插入图片描述"><br>右上角的p代表cos α的指数<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167097888891.png" alt="在这里插入图片描述"><br>下面不同p的值对于高光的影响<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167097888892.png" alt="在这里插入图片描述"></p><h2 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h2><p>计算环境光时，通常假设任何一个点接收到的环境光都是相同的，任何一个点也会有反射系数。L<del>a</del>是计算结果<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167097888893.png" alt="在这里插入图片描述"><br>从这个公式可以看出环境光和光照方向，观测光线都没有关系。</p><h2 id="Blinn-Phong反射模型"><a href="#Blinn-Phong反射模型" class="headerlink" title="Blinn-Phong反射模型"></a>Blinn-Phong反射模型</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167097888904.png" alt="在这里插入图片描述"><br>只需要对于场景中的每一个点都应用Blinn-Phong模型就可以对这个物体进行着色了</p><h2 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167097888905.png" alt="在这里插入图片描述"><br>着色频率就是指把着色应用到那些点上面<br>第一个球：对于每一个四边形面进行一次着色，这个面上的像素都是同一个颜色<br>第二个球：对于每一个平面的三个顶点，都计算它的法线然后对每一个顶点都做一次着色，而平面内部的点使用插值来确定颜色<br>第三个球：对于每一个三角形的平面求出一个法线然后把这些法线在三角形平面内部进行插值就得到了任何一个像素自己的法线方向，然后再进行着色。</p><p>三种着色模型：Flat shading、Gouraud shading、Phong shading</p><p>Flat shading<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167097888906.png" alt="在这里插入图片描述"></p><p>对三角形两边做叉乘就可以求出三角形法线，然后三角形进行一次着色，三角形内部都是这个颜色。（为每一个面着色）</p><p>Gouraud shading<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167097888907.png" alt="在这里插入图片描述"><br>先求出三角形的顶点的法线然后对每一个顶点做一次着色，三角形内部用插值的方法来确定其颜色。（为每一个顶点着色）</p><p>Phong shading<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167097888908.png" alt="在这里插入图片描述"><br>对于每一个像素进行一次着色</p><h2 id="不同着色模型的对比"><a href="#不同着色模型的对比" class="headerlink" title="不同着色模型的对比"></a>不同着色模型的对比</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167097888919.png" alt="在这里插入图片描述"><br>几何的形体足够复杂（细分曲面的面数足够多）时，其实就可以用一些相对简单的着色模型，效果与利用复杂的着色模型的效果几乎没有差别。相反当模型不太精细时应使用逐像素的着色。</p><h2 id="怎么求一个面的顶点的法线"><a href="#怎么求一个面的顶点的法线" class="headerlink" title="怎么求一个面的顶点的法线"></a>怎么求一个面的顶点的法线</h2><p>将该顶点所关联的三角形平面的法线求一个平均（简单平均或者加权平均），作为顶点的法线。顶点的法线为N<del>v</del><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/279cda760254495f881b6f52a5dda045.png" alt="在这里插入图片描述"></p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_12,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h2 id="实时渲染管线-Graphics-Real-time-Rendering-Pipeline"><a href="#实时渲染管线-Graphics-Real-time-Rendering-Pipeline" class="headerlink" title="实时渲染管线 Graphics (Real-time Rendering) Pipeline"></a>实时渲染管线 Graphics (Real-time Rendering) Pipeline</h2><p>怎么去渲染图形<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670978889110.png" alt="在这里插入图片描述"><br>过程：</p><ol><li>MVP变换</li><li>抽象成三角形</li><li>进行深度缓充</li><li>着色</li><li>纹理映射</li></ol><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670978889111.png" alt="在这里插入图片描述"></p><h2 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h2><p>又称纹理贴图，是将纹理空间中的纹理像素映射到屏幕空间中的像素的过程。简单来说，就是把一幅图像贴到三维物体的表面上来增强真实感</p><p>其中那个球的不同颜色就是由k_d的只来确定的（球上的所有点都是用的同一个着色模型，只是漫反射系数k_d不同），也就是说我们希望在物体不同位置定义不同的属性。因此引入纹理映射。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670978889112.png" alt="在这里插入图片描述"></p><h2 id="怎么定义一个点的基本属性"><a href="#怎么定义一个点的基本属性" class="headerlink" title="怎么定义一个点的基本属性"></a>怎么定义一个点的基本属性</h2><p>任何一个三维物体的表面都是二维的，也就是三维空间表面的点都可以对应二维空间中的一个点</p><p>纹理其实就是一张二维的图。将其覆盖在一个三维物体的表面这个叫做映射，合起来叫做纹理映射<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670978889113.png" alt="在这里插入图片描述"></p><h2 id="怎么确定纹理和三维物体的对于关系"><a href="#怎么确定纹理和三维物体的对于关系" class="headerlink" title="怎么确定纹理和三维物体的对于关系"></a>怎么确定纹理和三维物体的对于关系</h2><p>纹理上每个点都有其坐标（u，v）    。u，v的范围是在0~1<br>三角形三个顶点，每个顶点都对应一个uv。<br>越红则u越大<br>越绿则v越大<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670978889214.png" alt="在这里插入图片描述"><br>有一张图<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670978889215.png" alt="在这里插入图片描述"><br>这张图片的纹理坐标为<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%83%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670978889216.png" alt="在这里插入图片描述"><br>观察地面部分的纹理可得：<br>同一个纹理可以被重复应用到不同位置</p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（六）着色（光照与基本着色模型）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p> 本节设计内容：</p><ol><li><p>遮挡<br>深度缓冲（Z-buffering）</p></li><li><p>着色</p><p> 光照与着色<br> 图形管线着色</p></li></ol><h2 id="深度缓存"><a href="#深度缓存" class="headerlink" title="深度缓存"></a>深度缓存</h2><p>深度缓存需要做两件事：<br>1、渲染图形（只渲染深度最小的像素）<br>2、记录深度最小的像素的深度</p><p>左边时渲染图形，右边是记录深度最小的像素的深度信息<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>渲染过程：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167096874331.png" alt="在这里插入图片描述"><br>R表示无穷大，当没有渲染图形时像素的深度信息为无穷大。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167096874332.png" alt="在这里插入图片描述"></p><h2 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h2><p>有关着色的一些定义<br>对于一个非平面的表面，只要面积足够小，我们就认为是一个平面。</p><p>观测方向：从着色点出发到摄像机<br>光照方向：从着色点到发光点<br>法线：垂直于平面的线<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167096874333.png" alt="在这里插入图片描述"><br>着色不考虑光线是否被物体遮挡，只考虑物体被光照到之后应该是一个什么样子（着色考虑物体的明暗变化）。也就是说着色不会去渲染物体的影子。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167096874334.png" alt="在这里插入图片描述"></p><h2 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h2><p>物体的不同朝向会造成接受到的光线不同</p><p>计算有多少光会被接收：<br>当物体表面与光照垂直时接收到了所有的光，旋转60°后只能接收一半的光，可以发现：光照强度和法线与光照方向夹角的余弦成正比。即光照强度&#x3D;cos θ&#x3D; l 点乘 n<br>（l和n是单位向量）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167096874335.png" alt="在这里插入图片描述"></p><p>接下来计算有多少光会传播到反射点<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167096874346.png" alt="在这里插入图片描述"><br>4πl&#x3D;4πr^2^*I<br>解得：I&#x3D;I&#x2F;r^2^   (右边得l为未知数)<br>这样我们就知道了某一点的光照强度和它能接收的光，接下俩就可以计算漫反射了</p><p>满发射计算公式：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167096874347.png" alt="在这里插入图片描述"></p><ul><li>这里有max（0，n点乘l）是因为当n点乘l为负数时，代表有一个光线从下面达到了该点，这种情况下不予考虑，所以这种情况下接收光的数量为0</li><li>对于某一个点，自身是带有颜色的，也就是是说这个点它本身会吸收一部分光线，k<del>d</del>代表这个点的反射率，当k<del>d</del>为1时就是将全部的光都反射出去，为0时就是吸收全部的光。</li><li>满发射打到一个点上，能量会被均匀的反射到周围，就意味着无论从哪里观测它能量都是一样的，满发射和观测方向（v）没有关系</li></ul><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%85%AD%EF%BC%89%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>一束光线照射到某个点，光会被均匀地反射到各个方向。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（五）光栅化（深度测试与抗锯齿）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本节内容</p><ol><li><p>反走样</p><pre><code class="hljs"> 采样理论 图形学中怎么实现反走样</code></pre></li><li><p>遮挡与可见性</p></li></ol><p>采样造成走样的本质：<br>信号的变化太快了，以至于采样的速度跟不上变化的速度。</p><h2 id="反走样的方法"><a href="#反走样的方法" class="headerlink" title="反走样的方法"></a>反走样的方法</h2><p>1、在采样前做模糊操作，然后再去采样。</p><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>结果反走样之后的效果：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167095180851.png" alt="在这里插入图片描述"><br>对于先采样后模糊的操作（顺序与反走样相反）我们称之为Blurred Aliasing,即把走样后的图像进行了模糊操作。这样处理的图片并不清楚。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167095180852.png" alt="在这里插入图片描述"></p><h2 id="理解频率"><a href="#理解频率" class="headerlink" title="理解频率"></a>理解频率</h2><p>傅里叶级数展开：任何一个周期函数都可以写成一系列正弦和余弦函数的线性组合以及一个常数项<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167095180853.png" alt="在这里插入图片描述"><br>从f（x）&#x3D;A&#x2F;2（最低的频率）开始，每次不断地向式子中加入一些正余弦函数，然后画出新的图像，会发现当加入的项越多时，整个f（x）函数的图像越接近于原始的那个像城墙一样的原函数。</p><p>说明任何一个函数都可以使用傅里叶变换（图像也不例外）</p><h2 id="走样的概念"><a href="#走样的概念" class="headerlink" title="走样的概念"></a>走样的概念</h2><p>High-frequency signal is insufficiently sampled: samples erroneously appear to be from a low-frequency signal<br>高频信号采样不足:采样错误地显示为低频信号</p><p>Two frequencies that are indistinguishable at a given sampling rate are called “aliases”<br>在给定的采样率下不能区分的两个频率称为“走样”。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167095180854.png" alt="在这里插入图片描述"></p><h2 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h2><p>是将信号中特定波段频率滤除的操作，是抑制和防止干扰的一项重要措施。</p><p>右边是左图经过傅里叶变换后的频域，越靠近中心代表频率越低，越靠近外侧代表频率越高，白线是因为图像边界引起的。（这里的频率是指 图像颜色变化的激烈程度）</p><p>中间很亮代表该图像有很多一大块一大块的色块，各个像素点之间的颜色变化并不明显，只有人物边缘部分的像素变化明显一点。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167095180865.png" alt="在这里插入图片描述"></p><h2 id="高通滤波（抹除低频信号，高频信号可以通过）"><a href="#高通滤波（抹除低频信号，高频信号可以通过）" class="headerlink" title="高通滤波（抹除低频信号，高频信号可以通过）"></a>高通滤波（抹除低频信号，高频信号可以通过）</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167095180866.png" alt="在这里插入图片描述"><br>可以看到摸出低频信号后图像只保留了轮廓信息（高频信息）。这种滤波叫做高通滤波</p><h2 id="低通滤波：（抹除高频信号，低频信号可以通过）"><a href="#低通滤波：（抹除高频信号，低频信号可以通过）" class="headerlink" title="低通滤波：（抹除高频信号，低频信号可以通过）"></a>低通滤波：（抹除高频信号，低频信号可以通过）</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167095180867.png" alt="在这里插入图片描述"><br>低通滤波 去掉了高频信息，即细节信息，留下的低频信息代表了概貌。常用的例子，比如美图秀秀的磨皮，去掉了脸部细节信息（痘坑，痘印，暗斑等）。高通滤波则相反。</p><h2 id="滤波又可以理解为平均或者卷积"><a href="#滤波又可以理解为平均或者卷积" class="headerlink" title="滤波又可以理解为平均或者卷积"></a>滤波又可以理解为平均或者卷积</h2><p>当我们在求经过滤波后的某个数时，会去参考其周围的几个数。这里是对周围一个数按权求和，得到一个新的数，这个数就是滤波处理后的结果，这种操作叫做卷积。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167095180868.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167095180869.png" alt="在这里插入图片描述"></p><h2 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h2><p>时域上卷积&#x3D;在频域上乘积</p><p>通过这个定理就知道了怎么样去做一个卷积<br>方式一：<br>    可以直接用图片然后进行卷积操作<br>方式二：<br>    首先将图片进行傅里叶变换变到频域上，然后将卷积的滤波器变到频域上，把这两者相乘得到频域上的结果，然后做逆傅里叶变换变为时域上。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808610.png" alt="在这里插入图片描述"><br>用一个3×3的卷积盒，任何一个像素都是它周围对应的8个格子像素的平均。<br>通过观察图像知道，这个卷积操作相当于进行了一次低通滤波。</p><p>卷积盒越大则对应的频域越小。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808611.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808712.png" alt="在这里插入图片描述"></p><h2 id="从频率的角度理解采样"><a href="#从频率的角度理解采样" class="headerlink" title="从频率的角度理解采样"></a>从频率的角度理解采样</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808713.png" alt="在这里插入图片描述"><br>可以发现，频域上原始信号被copy了很多个。所以采样实质就是重复原始信号它的频谱。</p><h2 id="从频率的角度理解走样"><a href="#从频率的角度理解走样" class="headerlink" title="从频率的角度理解走样"></a>从频率的角度理解走样</h2><p>理解了采样的实质后就可以理解走样了。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808714.png" alt="在这里插入图片描述"><br>如果采样率不足（采样不够快），那么信号“复制粘贴”中间的间隔就会非常小（采样间隔时间大，换算成频率的话就是频率间隔小）而走样就是频谱发生了重叠。</p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>方法：先把一个信号高频信息去掉（做低通滤波，即模糊操作），然后再采样。</p><p>利用频谱证明：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808715.png" alt="在这里插入图片描述"></p><h2 id="怎么实现把图像变模糊"><a href="#怎么实现把图像变模糊" class="headerlink" title="怎么实现把图像变模糊"></a>怎么实现把图像变模糊</h2><p>我们只需要对于每一个像素都进行卷积操作就行了。</p><p>通过计算平均像素值来抗锯齿<br>在对一个三角形进行光栅化时，f(x,y) &#x3D; inside(triangle,x,y)像素区域内的平均值等于该三角形所覆盖的像素区域的面积。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808716.png" alt="在这里插入图片描述"><br>假设最左边的黑色覆盖了1&#x2F;8，即有7&#x2F;8没覆盖，也就是有87.5%的白色，最右边的黑色全部覆盖，也就是有0%的白色（纯黑色）</p><h2 id="实际中的反走样方法"><a href="#实际中的反走样方法" class="headerlink" title="实际中的反走样方法"></a>实际中的反走样方法</h2><p>如果要实现上一节中计算像素被覆盖的面积是多少在现实中是非常困难的。所以采用了下面的方法。</p><p>MSAA：MSAA是MultiSampling Anti-Aliasing的英文缩写，指多重采样抗锯齿，原理是寻找出物体边缘部分的像素，然后再把画缩放到当前的显示器上。</p><p>MSAA原理：<br>通过对一个像素内的多个位置进行采样并取其平均值来确定一个像素被覆盖了多少，即增加一个像素内采样点的数量来确定被覆盖的范围。</p><p>没采用MSAA：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808717.png" alt="在这里插入图片描述"><br>采用了MSAA：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808718.png" alt="在这里插入图片描述"><br>最终结果：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670951808719.png" alt="在这里插入图片描述"><br>其他抗锯齿的方法：<br>FXAA（Fast Approximate AA）<br>首先得到一幅图（有锯齿），然后找到有锯齿边界，然后把边界换成没有锯齿的边界。</p><p>TAA（Temporal AA）<br>复用上一帧的结果，上一帧的值在这一帧也会发挥作用</p><p>Super resolution &#x2F; super sampling   （超采样技术）<br>• From low resolution to high resolution （从低分辨率到高分辨率  ）<br>• Essentially still “not enough samples” problem （本质上仍然是“样本不足”的问题  ）<br>• DLSS (Deep Learning Super Sampling)(深度学习超级采样)  </p><p>超采样技术：有一种512p的图，现在需要把它用1080p来显示，如果直接放大就会导致很严重的锯齿现象，那么就需要去填充放大之后缺乏的像素点，可以使用深度学习的方法让电脑来去猜这个像素应该填什么颜色，这就是DLSS。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图像学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（四）光栅化（三角形的离散化）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="光栅化（Rasterization）"><a href="#光栅化（Rasterization）" class="headerlink" title="光栅化（Rasterization）"></a>光栅化（Rasterization）</h2><p>Rasterize&#x3D;drawing onto the screen<br>光栅化&#x3D;把东西画在屏幕上</p><p>屏幕空间的定义：<br>左下角是原点，向右是+x，向上是+y<br>像素的坐标从（0，0）开始，最大（width-1，height-1）<br>像素的中心点（x+0.5，y+0.5）<br>屏幕覆盖范围：（0，0）到（width，height）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>接下来就是在屏幕上面显示上一节中的哪个【-1，1】^3^的立方体<br>1、首先我们忽略调z轴<br>2、然后宽度变为width，高度变为height<br>3、然后就是将立方体的中心移动屏幕的中心（屏幕的左下角在（0，0）位置，中心在（width&#x2F;2,height&#x2F;2）位置，立方体原来的中心在（0，0）位置）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167094263981.png" alt="在这里插入图片描述"></p><h2 id="为什么三角形在计算机图形学中得到广泛得应用"><a href="#为什么三角形在计算机图形学中得到广泛得应用" class="headerlink" title="为什么三角形在计算机图形学中得到广泛得应用"></a>为什么三角形在计算机图形学中得到广泛得应用</h2><ol><li>三角形是最为基础的多边形</li><li>任何多边形都可以被拆分成三角形</li><li>给定三个点可以确定一个三角形，并且可以确定一个平面</li></ol><h2 id="光栅化最重要的工作"><a href="#光栅化最重要的工作" class="headerlink" title="光栅化最重要的工作"></a>光栅化最重要的工作</h2><p>判断每一个可能要显示图形的像素的中心点和图形的位置关系，究竟是该显示图形还是不显示图形。</p><h2 id="怎么实现光栅化"><a href="#怎么实现光栅化" class="headerlink" title="怎么实现光栅化"></a>怎么实现光栅化</h2><p>通过采样的方法实现光栅化，采样就是将一个连续函数离散化。</p><p>Evaluating a function at a point is sampling.<br>在某一点求函数数值就是采样</p><p>采样是图形化的核心<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167094263982.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_17,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>可以使用下面的方法来判断一个像素的中心点是否在三角形里面。<br>即：第二节提到的向量的点乘。（全在右侧或者全在左侧&#x3D;点在三角形内）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E5%9B%9B%EF%BC%89%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167094263993.png"><br>jaggies： 锯齿<br>aliasing：走样</p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（三）变换（模型、视图、投影）</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p>R<del>θ</del>是逆时针方向旋转的矩阵<br>R<del>-θ</del>是顺时针方向旋转的矩阵<br>可以发现R<del>θ</del>^T^&#x3D;R<del>θ</del>^-1^，像这样的矩阵叫做正交矩阵。以后如果要求往相反的方向旋转相同角度的变换（R<del>-θ</del>），只需要求正向旋转的矩阵然后转置就可以了<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br> 本节涉及内容：<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167093197891.png" alt="在这里插入图片描述"><br>仿射变换：线性变换+平移</p><p>三维空间中的变换矩阵格式：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167093197892.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167093197903.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167093197904.png" alt="在这里插入图片描述"></p><h2 id="3D旋转"><a href="#3D旋转" class="headerlink" title="3D旋转"></a>3D旋转</h2><p>任意一个旋转都可以被分解为绕着X，Y，Z轴的旋转 即：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/0ce4e7732b974ea0a60b760ff8df4830.png" alt="在这里插入图片描述"><br>α β γ这三个角叫做欧拉角（Euler angles）</p><h2 id="罗德里格斯公式"><a href="#罗德里格斯公式" class="headerlink" title="罗德里格斯公式"></a>罗德里格斯公式</h2><p>该公式将解决了绕着任意方向的旋转<br>表示绕着向量n旋转α°可以使用下面这个公式。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167093197915.png" alt="在这里插入图片描述"><br>变换的最终目的是让三维空间的物体变为二维空间的一张照片。这样才能在电脑上面展示出来。</p><h2 id="怎么理解模型、视图、投影变换"><a href="#怎么理解模型、视图、投影变换" class="headerlink" title="怎么理解模型、视图、投影变换"></a>怎么理解模型、视图、投影变换</h2><p>我们拍一张照片需要摆动作（模型变换）<br>动作摆好后，需要找一个好的拍摄角度（视图变换）<br>拍照  （投影变换，将三维物体投影到二维的平面上面）</p><h2 id="怎么去定义视图变换"><a href="#怎么去定义视图变换" class="headerlink" title="怎么去定义视图变换"></a>怎么去定义视图变换</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167093197916.png" alt="在这里插入图片描述"><br>想要唯一的确定一个视角，首先需要定义相机在什么位置e（x，y，z），定义了相机的位置之后需要定义相机的朝向$\vec g$，确定朝向后相机仍可以绕着$\vec g$旋转，所以还需要一个$\vec t$来确定相机的向上方向，用来确定图片哪个方向是上方。</p><p>如果摄像机和场景中所有的东西一起移动的话，那么整个场景在摄像机中的画面还是相对保持不变。<br>一般情况下相机的位置位于原点，相机永远朝向-Z方向，相机的向上方向为Y方向。<br>这样图形变换的时候视角不需要改变只改变物体的位置即可。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167093197917.png" alt="在这里插入图片描述"></p><h2 id="现在需要将一个不在标准位置的视角变为标准位置"><a href="#现在需要将一个不在标准位置的视角变为标准位置" class="headerlink" title="现在需要将一个不在标准位置的视角变为标准位置"></a>现在需要将一个不在标准位置的视角变为标准位置</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_10,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>变为<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_11,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>那么我们需要做以下操作<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/dc9b1ca5f14044309121c95cc9b09ca4.png" alt="在这里插入图片描述"><br>首先需要将视图位置e移到原点<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/b2042e8ab67f4caaa2ddde29d7614c77.png" alt="在这里插入图片描述"><br>考虑到要将g旋转到-Z，t旋转到Y，（g x t）旋转到X比较难，所以先求其逆变换，然后通过正交矩阵的性质求原矩阵（R^T^&#x3D;R^-1^）。<br>其逆变换就是<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/a5e34b25598c4c76bbc2ba9cb2b5b32f.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/dbe2c59ffda84b1697fe71466ce6a100.png" alt="在这里插入图片描述"></p><p>利用R^T^&#x3D;R^-1^求得<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/4dde96c20b23476eaefa62ba15259c6b.png" alt="在这里插入图片描述"><br>至此就求出来视图变换得矩阵<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167093197938.png" alt="在这里插入图片描述"></p><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>正交投影：无论观看者在哪里，物体大小维持不变。没有近大远小，正交投影的视图是一个平面，所以物体大小不变，只是映射到一个平面上。<br>透视投影：近大远小，透视投影的视图是一个点，所以会改变物体大小，与我们日常习惯相符。<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167093197939.png" alt="在这里插入图片描述"></p><h2 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h2><p>计算机中正交投影对于一个物体的处理过程<br>我们要投影的立方体左（l） 右（r）是在x轴的值<br>我们要投影的立方体下（b）上（t）是在y轴的值<br>我们要投影的立方体远（f）近（n）是在z轴的值</p><p>1、将物体中心点平移到原点<br>2、将其缩放成一个标准 1<em>1</em>1 的立方体<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670931979410.png" alt="在这里插入图片描述"><br>计算过程：<br>只需要乘以矩阵M<del>ortho</del>即可<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670931979411.png" alt="在这里插入图片描述"></p><h2 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h2><p>步骤</p><p>1、first “squish” the frustum into a cuboid (n-&gt;n,f-&gt;f)（M<del>persp-&gt;ottho</del>）<br>首先把“截锥”挤压成一个长方体(n-&gt;n,f-&gt;f)  得到矩阵M<del>persp-&gt;ottho</del><br>2、Do orthographic projection<br>做正交投影，即M<del>ortho</del>*M<del>persp-&gt;ottho</del><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670931979412.png" alt="在这里插入图片描述"></p><h2 id="怎么去挤压"><a href="#怎么去挤压" class="headerlink" title="怎么去挤压"></a>怎么去挤压</h2><p>挤压得实质就是求一个挤压矩阵M<del>persp-&gt;ottho</del><br>红色的两个三角形形成一对相似三角形<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670931979413.png" alt="在这里插入图片描述"><br>挤压x和y变为：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/96ccadac9d6b43a38244cfde850193f3.png" alt="在这里插入图片描述"><br>使用齐次坐标表示并且写成矩阵乘法的形式<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670931979514.png" alt="在这里插入图片描述"><br>下面可以通过矩阵乘法反推出M<del>persp-&gt;ottho</del><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670931979515.png" alt="在这里插入图片描述"><br>M<del>persp-&gt;ottho</del>的最终结果：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/cbde2991300845f69d4060f55c178ef3.png" alt="在这里插入图片描述"><br>得到M<del>persp-&gt;ottho</del>后只要再做一次正交投影就可以完成透视投影了<br>M<del>persp</del>为透视投影的变换矩阵<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89/59d102dfe74740daaf66a8d86a7152e6.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（二）变换</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="本节涉及的内容"><a href="#本节涉及的内容" class="headerlink" title="本节涉及的内容"></a>本节涉及的内容</h2><p>1、2D变换：旋转、缩放、切变<br>2、齐次坐标<br>3、变换的组合</p><p>变换一般使用矩阵来表示</p><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><ol><li>缩放变换<br> x’   y’代表变换后的坐标，s代表缩放的比例 ，x    y代表原来的坐标<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></li><li>镜像翻转<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167090267181.png" alt="在这里插入图片描述"></li><li>切变变换<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167090267192.png" alt="在这里插入图片描述"></li><li>旋转变换<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167090267193.png" alt="在这里插入图片描述"><br> 以上的变换都属于线性变换，都可以使用矩阵的乘法进行表示，形式如下<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167090267194.png" alt="在这里插入图片描述"><br> 一旦涉及到平移变换就没有办法使用矩阵的乘法来表示了（平移变换不是线性变换）<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167090267195.png" alt="在这里插入图片描述"><br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/34fcef89a589414880f412a7ea8a3001.png" alt="平移变换不是线性变换"><br> 为了使得平移变换也能使用矩阵乘法的形式来表示，我们引入了齐次坐标<br> 二维空间的点写成<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/acd0fbfc2c14478a848e6715cabe25e7.png" alt="在这里插入图片描述"><br> 二维空间的向量写成<br> <img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/4b8b722aa6ea4eb2a115baac8dd76a77.png" alt="在这里插入图片描述"><br> 即使用n+1维坐标来表示n维空间，最后一维等于1代表点 ，等于0代表向量</li></ol><p>使用齐次坐标的目的是为了平移变换也可以使用矩阵乘法的形式来表示，即<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/0878108474824ef7a33066e1dc42635e.png" alt="在这里插入图片描述"><br>tx表示沿x轴方向的平移量<br>ty表示沿y轴方向的平移量</p><h2 id="引入其次坐标后的计算"><a href="#引入其次坐标后的计算" class="headerlink" title="引入其次坐标后的计算"></a>引入其次坐标后的计算</h2><p>我们知道齐次坐标最后一维为0代表向量，为1代表点，那么齐次坐标怎么运算呢？<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>第一种形式，向量+向量&#x3D;向量 。即（x<del>1</del>，y<del>1</del>，0）+（x<del>2</del>，y<del>2</del>，0）&#x3D;（x<del>1</del>+x<del>2</del>，y<del>1</del>+y<del>2</del>，0+0&#x3D;0）。最后一维还是0，表示向量。符合数学中的运算法则。<br>第二种形式，点-点&#x3D;向量。即（x<del>1</del>，y<del>1</del>，1）-（x<del>2</del>，y<del>2</del>，1）&#x3D;（x<del>1</del>-x<del>2</del>，y<del>1</del>-y<del>2</del>，1-1&#x3D;0）。最后一维是0，表示向量。符合数学中的运算法则。<br>第三种形式，点+向量&#x3D;点。即（x<del>1</del>，y<del>1</del>，1）+（x<del>2</del>，y<del>2</del>，0）&#x3D;（x<del>1</del>+x<del>2</del>，y<del>1</del>+y<del>2</del>，1+0&#x3D;1）。最后一维是1，表示点。该运算代表（x<del>1</del>，y<del>1</del>）这个点沿着向量（x<del>2</del>，y<del>2</del>）运动到了（x<del>1</del>+x<del>2</del>，y<del>1</del>+y<del>2</del>）这个坐标。<br>第四种形式，（x<del>1</del>，y<del>1</del>，1）+（x<del>2</del>，y<del>2</del>，1）&#x3D;（x<del>1</del>+x<del>2</del>，y<del>1</del>+y<del>2</del>，1+1&#x3D;2）其代表的点为（x&#x2F;w,y&#x2F;w，1）。如图：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/45a26065ea5b4a24bc6e7ac82b95f8c9.png" alt="在这里插入图片描述"></p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>类似于下面这种格式的变换叫做放射变换<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/7c0ca0a93dda4eb4afc75b284861b43f.png" alt="在这里插入图片描述"><br>写成矩阵乘法的形式<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/e2bb0b643c20467197d692c2e0e8fabf.png" alt="在这里插入图片描述"></p><h2 id="各种变换的矩阵形式"><a href="#各种变换的矩阵形式" class="headerlink" title="各种变换的矩阵形式"></a>各种变换的矩阵形式</h2><p>scale：缩放<br>rotation：旋转<br>translation：平移<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167090267216.png" alt="在这里插入图片描述"></p><h2 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h2><p>可以使得经过变换后的图形变为原来的图形的变换叫逆变换<br>逆变换在数学中体现为逆矩阵<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167090267217.png" alt="在这里插入图片描述"></p><h2 id="变换的分解"><a href="#变换的分解" class="headerlink" title="变换的分解"></a>变换的分解</h2><p>如何经过变换得到右边的图形？<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167090267228.png" alt="在这里插入图片描述"><br>结果：（T表示平移，R表示按逆时针方向旋转）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167090267229.png" alt="在这里插入图片描述"><br>可以看出：<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/d4969440f18e42fb8be4c877720e7761.png" alt="在这里插入图片描述"><br>这是因为矩阵乘法是不支持交换律的</p><p>所以该图形是经过了旋转45°后向右平移一个单位得到的<br>在书写时要写成：（矩阵从右往左运算）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/c4bbdc2df00e4521af3c8887dcbf2028.png" alt="在这里插入图片描述"></p><h2 id="变换的组合"><a href="#变换的组合" class="headerlink" title="变换的组合"></a>变换的组合</h2><p>当我们进行多次变换时，变换矩阵为A<del>1</del>，A<del>2</del>，A<del>3</del>，A<del>4</del>，A<del>n</del> ，我们可以将这些矩阵都乘起来，得到一个最终的变换矩阵，然后再去乘以（x，y，1）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670902672210.png" alt="在这里插入图片描述"></p><h2 id="旋转的中心点不在圆心的情况"><a href="#旋转的中心点不在圆心的情况" class="headerlink" title="旋转的中心点不在圆心的情况"></a>旋转的中心点不在圆心的情况</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%98%E6%8D%A2/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-171670902672211.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学GAMES101（一）向量与线性代数</title>
    <link href="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、向量"><a href="#一、向量" class="headerlink" title="一、向量"></a><strong>一、向量</strong></h2><h2 id="1、向量的基本概念"><a href="#1、向量的基本概念" class="headerlink" title="1、向量的基本概念"></a>1、向量的基本概念</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="请添加图片描述"><br>向量AB&#x3D;B-A，即终点减去起点 </p><p>单位向量<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/89d944ff68a0489ab711bc9cfbfb14e0.png" alt="在这里插入图片描述"></p><h2 id="2、向量的运算"><a href="#2、向量的运算" class="headerlink" title="2、向量的运算"></a>2、向量的运算</h2><p>向量的表达以及向量的模<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/a81c76a6ab7844ceb19b56e1f67ec44d.png" alt="在这里插入图片描述"><br>点乘<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167072977511.png" alt="在这里插入图片描述"><br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167072977512.png" alt="在这里插入图片描述"><br>向量的投影<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_13,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>b向量在a向量上的投影方向和a向量相同，长度为k倍<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/c428c77d2f48414aaf1c6884ab6074a8.png" alt="在这里插入图片描述"><br>求k可以使用下面的公式<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/9b775946c2e848a1aaabb4129aeab52d.png" alt="在这里插入图片描述"></p><h2 id="3、点乘在计算机图形学中的应用"><a href="#3、点乘在计算机图形学中的应用" class="headerlink" title="3、点乘在计算机图形学中的应用"></a>3、点乘在计算机图形学中的应用</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>可以利用点乘来求一个向量相对于另一个向量是方向相同还是相反<br>当a点乘b  结果&gt;0，a和b向量同向<br>当a点乘c  结果&lt;0，a和c向量反向</p><h2 id="4、叉乘"><a href="#4、叉乘" class="headerlink" title="4、叉乘"></a>4、叉乘</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_10,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>叉乘的结果仍是一个向量，可以使用右手定则来确定朝向，右手食指从a向量转向b向量大拇指的朝向就是最终结果的朝向。即叉乘的结果是垂直于a b向量所在的平面的，利用这个性只需要知道两个向量然后利用这两个向量的叉乘来构建一个三维坐标系。</p><p>叉乘的一些性质<img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167072977533.png" alt="在这里插入图片描述"><br>叉乘的坐标运算<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/62d293143eb945dcb640310a6f55f8dd.png" alt="在这里插入图片描述"><br>将叉乘写成矩阵乘法的形式<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167072977534.png" alt="在这里插入图片描述"></p><h2 id="5、叉乘在计算机图形学中的应用"><a href="#5、叉乘在计算机图形学中的应用" class="headerlink" title="5、叉乘在计算机图形学中的应用"></a>5、叉乘在计算机图形学中的应用</h2><p>1、判断一个向量对于另一个向量是在左侧还是右侧<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_17,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>a叉乘b 如果结果&gt;0   则b在a的左侧<br>b叉乘a 如果结果&lt;0   则a在b的右侧<br>判断方法：使用右手定理，从a向量旋转至b向量，发现大拇指朝外说明结果z是正的。b叉乘a同理</p><p>2、判断一个点是在里面还是外面<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_14,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>AB叉乘AP结果为正，说明AP在AB的左边<br>BC叉乘BP结果为正，说明BP在BC的左边<br>CA叉乘CP结果为正，说明CP在CA的左边<br>所以P点在这个三角形里面<br>总结：<br>如果P点在三角形里面 则叉乘的结果全部都是左边或者右边，不能两边都有。</p><h2 id="二、矩阵"><a href="#二、矩阵" class="headerlink" title="二、矩阵"></a>二、矩阵</h2><h2 id="1、矩阵的基本运算"><a href="#1、矩阵的基本运算" class="headerlink" title="1、矩阵的基本运算"></a>1、矩阵的基本运算</h2><p>矩阵乘法<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167072977535.png" alt="在这里插入图片描述"><br>矩阵乘法的一些性质（矩阵乘法没有交换率）<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/c3731a48e1f84ab7a5065088d60f4353.png" alt="在这里插入图片描述"><br>矩阵的转置<br><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167072977546.png" alt="在这里插入图片描述"></p><h2 id="2、单位矩阵和逆矩阵"><a href="#2、单位矩阵和逆矩阵" class="headerlink" title="2、单位矩阵和逆矩阵"></a>2、单位矩阵和逆矩阵</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_16,color_FFFFFF,t_70,g_se,x_16-17167072977547.png" alt="在这里插入图片描述"></p><h2 id="3、将向量的点乘和叉乘写成矩阵相乘的形式"><a href="#3、将向量的点乘和叉乘写成矩阵相乘的形式" class="headerlink" title="3、将向量的点乘和叉乘写成矩阵相乘的形式"></a>3、将向量的点乘和叉乘写成矩阵相乘的形式</h2><p><img src="/2024/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6GAMES101%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbW9tb2hvbGE=,size_20,color_FFFFFF,t_70,g_se,x_16-17167072977548.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity英文自动添加连词符“-”</title>
    <link href="/2024/03/16/Unity-hyphen/"/>
    <url>/2024/03/16/Unity-hyphen/</url>
    
    <content type="html"><![CDATA[<p>unity自带的text组件当需要换行时会自动把整个单词都移动到下一行，比如下面的情况:</p><p><img src="/2024/03/16/Unity-hyphen/438bef10aae34a0eb4ff46cf3742f15d.gif" alt="请添加图片描述"></p><p>但当我们有一大段文字的时候这种换行规则会导致文字的右边不能完美的与边缘对齐，会空出来一大片，导致美观度降低。</p><p><img src="/2024/03/16/Unity-hyphen/9a7456e200d14efbbb5a24fe32c42b62.png" alt="在这里插入图片描述"></p><p>所以采用在单词中间进行截断并且添加连词符（-）的方式来避免这种情况的产生。</p><p><img src="/2024/03/16/Unity-hyphen/e1b6e52d2b754162bac5519d8216719e.png" alt="在这里插入图片描述"></p><p><img src="/2024/03/16/Unity-hyphen/1bf063dd857a4f22af12f6018c722fb8.gif" alt="请添加图片描述"></p><p>其主要是利用GetGenerationSettings接口获取字符串的渲染宽度从而自动自动添加连字符，lua 5.1本版需要下载utf8扩展库，其他lua5.3版本自带utf8库，但接口名字有所不同，推荐点击下面的Github链接下载</p><p>C#代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UITest</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Text lab;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        lab = transform.Find(<span class="hljs-string">&quot;Text&quot;</span>).GetComponent&lt;Text&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> temp = <span class="hljs-string">&quot;lua integration state where scale in projects lua integration state where scale in projects lua integration state where scale in projects lua integration state where scale in projectslua integration state where scale in projects&quot;</span>;<br>        temp = temp.Replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;\u00A0&quot;</span>);<br>        lab.text = temp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> temp = <span class="hljs-string">&quot;lua integration state where scale in projects lua integration state where scale in projects lua integration state where scale in projects lua integration state where scale in projectslua integration state where scale in projects&quot;</span>;<br>        temp = temp.Replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;\u00A0&quot;</span>);<br>        lab.text = temp;<br>        WrapTextWithHyphen(lab, temp);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WrapTextWithHyphen</span>(<span class="hljs-params">Text textComponent, <span class="hljs-built_in">string</span> str</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> originalText = str;<br>        <span class="hljs-built_in">string</span>[] words = originalText.Split(<span class="hljs-string">&#x27;\u00A0&#x27;</span>);<br><br>        <span class="hljs-built_in">float</span> textWidth = textComponent.rectTransform.rect.width;<br>        <span class="hljs-built_in">string</span> wrappedText = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">string</span> line = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; words.Length; i++)<br>        &#123;<br>            <span class="hljs-built_in">string</span> word = words[i];<br>            <span class="hljs-built_in">string</span> spaceLine = line + <span class="hljs-string">&quot;\u00A0&quot;</span>;<br>            <span class="hljs-keyword">if</span> (GetTextPreferredWidth(textComponent,spaceLine + word) &gt; textWidth)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;= word.Length; j++)<br>                &#123;<br>                    <span class="hljs-built_in">string</span> substring = word.Substring(<span class="hljs-number">0</span>, j);<br>                    <span class="hljs-keyword">if</span> (GetTextPreferredWidth(textComponent,spaceLine + substring + <span class="hljs-string">&quot;-&quot;</span>) &gt; textWidth)<br>                    &#123;<br>                        <span class="hljs-comment">//防止刚好是空格+单个字母+&quot;-&quot;超行的情况，这个时候直接把这个单词放到下一行</span><br>                        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>)<br>                        &#123;<br>                            wrappedText += line + <span class="hljs-string">&quot; &quot;</span>;<br>                            line = word;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            <span class="hljs-built_in">string</span> tempStr = spaceLine + word.Substring(<span class="hljs-number">0</span>, j - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;-\n&quot;</span>;<br>                            wrappedText += tempStr;<br>                            line = word.Substring(j - <span class="hljs-number">1</span>);<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(line))<br>                &#123;<br>                    line += <span class="hljs-string">&quot;\u00A0&quot;</span>; <br>                &#125;<br>                line += word;<br>            &#125;<br>        &#125;<br><br>        wrappedText += line;<br>        textComponent.supportRichText = <span class="hljs-literal">true</span>;<br>        textComponent.text = wrappedText;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> <span class="hljs-title">GetTextPreferredWidth</span>(<span class="hljs-params">Text textComp, <span class="hljs-built_in">string</span> content</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> textComp.cachedTextGenerator.GetPreferredWidth(content,<br>            textComp.GetGenerationSettings(textComp.rectTransform.rect.size));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>lua代码：(lua 的utf8库点击下面的链接下载)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- hyphen_util.txt --------------------------------------------------</span><br><span class="hljs-comment">-- author:</span><br><span class="hljs-comment">-- date: </span><br><span class="hljs-comment">-- ver:  </span><br><span class="hljs-comment">-- desc:    自动添加连词符</span><br><span class="hljs-comment">-------------------------------------------------------------------</span><br><br><span class="hljs-keyword">local</span> event = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;event&quot;</span><br><span class="hljs-keyword">local</span> util = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;util&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">log</span> = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-keyword">local</span> lang = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;lang&quot;</span><br><span class="hljs-keyword">local</span> utf8 = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;utf8&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">tostring</span> = <span class="hljs-built_in">tostring</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">ipairs</span> = <span class="hljs-built_in">ipairs</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">require</span> = <span class="hljs-built_in">require</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">dump</span> = <span class="hljs-built_in">dump</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">print</span> = <span class="hljs-built_in">print</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">string</span> = <span class="hljs-built_in">string</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">tonumber</span> = <span class="hljs-built_in">tonumber</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">type</span> = <span class="hljs-built_in">type</span><br><span class="hljs-keyword">local</span> typeof = typeof<br><br><span class="hljs-built_in">module</span>(<span class="hljs-string">&quot;hyphen_util&quot;</span>)<br><br><span class="hljs-keyword">local</span> isEnable = <span class="hljs-literal">true</span>  <span class="hljs-comment">--启用功能</span><br><br><span class="hljs-comment">--下面这些字符前面和后面不会添加连词符</span><br><span class="hljs-keyword">local</span> noAppendHyphenCharacter =<br>&#123;<br>    [<span class="hljs-string">&quot;-&quot;</span>]=<span class="hljs-string">&quot;-&quot;</span>,<br>    [<span class="hljs-string">&quot;.&quot;</span>]=<span class="hljs-string">&quot;.&quot;</span>,<br>    [<span class="hljs-string">&quot;,&quot;</span>]=<span class="hljs-string">&quot;,&quot;</span>,<br>    [<span class="hljs-string">&quot;。&quot;</span>]=<span class="hljs-string">&quot;。&quot;</span>,<br>    [<span class="hljs-string">&quot;，&quot;</span>]=<span class="hljs-string">&quot;，&quot;</span>,<br>    [<span class="hljs-string">&quot;&#123;&quot;</span>]=<span class="hljs-string">&quot;&#123;&quot;</span>,<br>    [<span class="hljs-string">&quot;&#125;&quot;</span>]=<span class="hljs-string">&quot;&#125;&quot;</span>,<br>    [<span class="hljs-string">&quot;(&quot;</span>]=<span class="hljs-string">&quot;(&quot;</span>,<br>    [<span class="hljs-string">&quot;)&quot;</span>]=<span class="hljs-string">&quot;)&quot;</span>,<br>    [<span class="hljs-string">&quot;（&quot;</span>]=<span class="hljs-string">&quot;（&quot;</span>,<br>    [<span class="hljs-string">&quot;）&quot;</span>]=<span class="hljs-string">&quot;）&quot;</span>,<br>    [<span class="hljs-string">&quot;[&quot;</span>]=<span class="hljs-string">&quot;[&quot;</span>,<br>    [<span class="hljs-string">&quot;]&quot;</span>]=<span class="hljs-string">&quot;]&quot;</span>,<br>    [<span class="hljs-string">&quot;|&quot;</span>]=<span class="hljs-string">&quot;|&quot;</span>,<br>    [<span class="hljs-string">&quot;&amp;&quot;</span>]=<span class="hljs-string">&quot;&amp;&quot;</span>,<br>    [<span class="hljs-string">&quot;*&quot;</span>]=<span class="hljs-string">&quot;*&quot;</span>,<br>    [<span class="hljs-string">&quot;/&quot;</span>]=<span class="hljs-string">&quot;/&quot;</span>,<br>    [<span class="hljs-string">&quot;\\&quot;</span>]=<span class="hljs-string">&quot;\\&quot;</span>,<br>    [<span class="hljs-string">&quot;#&quot;</span>]=<span class="hljs-string">&quot;#&quot;</span>,<br>    [<span class="hljs-string">&quot;%&quot;</span>]=<span class="hljs-string">&quot;%&quot;</span>,<br>    [<span class="hljs-string">&quot;~&quot;</span>]=<span class="hljs-string">&quot;~&quot;</span>,<br>    [<span class="hljs-string">&quot;、&quot;</span>]=<span class="hljs-string">&quot;、&quot;</span>,<br>    [<span class="hljs-string">&quot;:&quot;</span>]=<span class="hljs-string">&quot;:&quot;</span>,<br>    [<span class="hljs-string">&quot;;&quot;</span>]=<span class="hljs-string">&quot;;&quot;</span>,<br>    [<span class="hljs-string">&quot;?&quot;</span>]=<span class="hljs-string">&quot;?&quot;</span>,<br>    [<span class="hljs-string">&quot;?&quot;</span>]=<span class="hljs-string">&quot;?&quot;</span>,<br>    [<span class="hljs-string">&quot;!&quot;</span>]=<span class="hljs-string">&quot;!&quot;</span>,<br>    [<span class="hljs-string">&quot;`&quot;</span>]=<span class="hljs-string">&quot;`&quot;</span>,<br>    [<span class="hljs-string">&quot;\&#x27;&quot;</span>]=<span class="hljs-string">&quot;\&#x27;&quot;</span>,<br>    [<span class="hljs-string">&quot;\&quot;&quot;</span>]=<span class="hljs-string">&quot;\&quot;&quot;</span>,<br>    [<span class="hljs-string">&quot;$&quot;</span>]=<span class="hljs-string">&quot;$&quot;</span>,<br>    [<span class="hljs-string">&quot;_&quot;</span>]=<span class="hljs-string">&quot;_&quot;</span>,<br>    [<span class="hljs-string">&quot;0&quot;</span>]=<span class="hljs-string">&quot;0&quot;</span>,<br>    [<span class="hljs-string">&quot;1&quot;</span>]=<span class="hljs-string">&quot;1&quot;</span>,<br>    [<span class="hljs-string">&quot;2&quot;</span>]=<span class="hljs-string">&quot;2&quot;</span>,<br>    [<span class="hljs-string">&quot;3&quot;</span>]=<span class="hljs-string">&quot;3&quot;</span>,<br>    [<span class="hljs-string">&quot;4&quot;</span>]=<span class="hljs-string">&quot;4&quot;</span>,<br>    [<span class="hljs-string">&quot;5&quot;</span>]=<span class="hljs-string">&quot;5&quot;</span>,<br>    [<span class="hljs-string">&quot;6&quot;</span>]=<span class="hljs-string">&quot;6&quot;</span>,<br>    [<span class="hljs-string">&quot;7&quot;</span>]=<span class="hljs-string">&quot;7&quot;</span>,<br>    [<span class="hljs-string">&quot;8&quot;</span>]=<span class="hljs-string">&quot;8&quot;</span>,<br>    [<span class="hljs-string">&quot;9&quot;</span>]=<span class="hljs-string">&quot;9&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">---自动添加连词符，添加连词符需要关闭bestfit、开启富文本显示，只能给needAppendHyphenLanguage列表里面的语言添加连词符</span><br><span class="hljs-comment">---@param textComponent text text组件</span><br><span class="hljs-comment">---@param str string</span><br><span class="hljs-comment">---@param delayTime double 延迟时间，部分text在赋值之后需要短暂延迟才能计算text组件的宽度</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AutoAppendHyphen</span><span class="hljs-params">(textComponent, str, delayTime)</span></span><br>    <span class="hljs-keyword">local</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isEnable <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">if</span> IsNullOrEmpty(str) <span class="hljs-keyword">then</span><br>            str = textComponent.text<br>            <span class="hljs-keyword">if</span> str == <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>        textComponent.resizeTextForBestFit = <span class="hljs-literal">false</span><br>        textComponent.supportRichText = <span class="hljs-literal">true</span><br>        textComponent.text = GetAppendHyphenStr(textComponent, str)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> delayTime <span class="hljs-keyword">then</span><br>        util.DelayCallOnce(delayTime, func)   <span class="hljs-comment">--需要自己实现延迟功能</span><br>    <span class="hljs-keyword">else</span><br>        func()<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">---返回添加了连词符的文本</span><br><span class="hljs-comment">---@param textComponent text text组件</span><br><span class="hljs-comment">---@param str string</span><br><span class="hljs-comment">---@return string 返回添加了连词符的文本</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetAppendHyphenStr</span><span class="hljs-params">(textComponent, str)</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isEnable <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> str<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> IsNullOrEmpty(str) <span class="hljs-keyword">then</span><br>        str = textComponent.text<br>        <span class="hljs-keyword">if</span> str == <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> str<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> separator = <span class="hljs-string">&quot; &quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(str, <span class="hljs-string">&quot; &quot;</span>) <span class="hljs-keyword">then</span><br>        separator = <span class="hljs-string">&quot; &quot;</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> words = <span class="hljs-built_in">string</span>.split(str, separator)   <span class="hljs-comment">--按照单词进行分割</span><br>    <span class="hljs-keyword">local</span> textWidth = textComponent.rectTransform.rect.width     <span class="hljs-comment">--获得当前的文本框宽度</span><br>    <span class="hljs-keyword">local</span> line = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">local</span> wrappedText = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(words) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">local</span> spaceLine = line .. separator<br>        <span class="hljs-keyword">if</span> GetTextPreferredWidth(textComponent, spaceLine .. word) &gt; textWidth <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">local</span> substring = <span class="hljs-string">&quot;&quot;</span>                <span class="hljs-comment">--截断的单词</span><br>            <span class="hljs-keyword">local</span> lastSubString = <span class="hljs-string">&quot;&quot;</span>            <span class="hljs-comment">--上一个截断单词</span><br>            <span class="hljs-keyword">local</span> isFind = <span class="hljs-literal">false</span>                <span class="hljs-comment">--是都找到了断行的位置</span><br>            <span class="hljs-keyword">local</span> leaveStr = <span class="hljs-string">&quot;&quot;</span>                 <span class="hljs-comment">--剩余的字符串</span><br>            <span class="hljs-keyword">local</span> oldChar                       <span class="hljs-comment">--上一个字符</span><br>            <span class="hljs-keyword">for</span> pos, <span class="hljs-built_in">char</span> <span class="hljs-keyword">in</span> utf8.codes(word) <span class="hljs-keyword">do</span><br>                substring = substring .. <span class="hljs-built_in">char</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isFind <span class="hljs-keyword">and</span> GetTextPreferredWidth(textComponent,spaceLine .. substring .. <span class="hljs-string">&quot;-&quot;</span>) &gt; textWidth <span class="hljs-keyword">then</span><br>                    <span class="hljs-comment">--防止刚好是空格+单个字母+&quot;-&quot;超行的情况，这个时候直接把这个单词放到下一行</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> oldChar <span class="hljs-keyword">then</span><br>                        wrappedText = wrappedText .. line  .. <span class="hljs-string">&quot;\n&quot;</span><br>                        line = word<br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span><br>                        wrappedText = wrappedText .. spaceLine .. lastSubString<br>                        <span class="hljs-keyword">if</span> noAppendHyphenCharacter[<span class="hljs-built_in">char</span>] <span class="hljs-keyword">or</span> noAppendHyphenCharacter[oldChar] <span class="hljs-keyword">then</span>   <span class="hljs-comment">--防止出现连续两个换行符的情况</span><br>                            wrappedText = wrappedText .. <span class="hljs-string">&quot;\n&quot;</span><br>                        <span class="hljs-keyword">else</span><br>                            wrappedText = wrappedText .. <span class="hljs-string">&quot;-\n&quot;</span><br>                        <span class="hljs-keyword">end</span><br>                        <span class="hljs-comment">--wrappedText = wrappedText .. spaceLine .. lastSubString .. &quot;-\n&quot;</span><br>                        isFind = <span class="hljs-literal">true</span><br>                    <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">if</span> isFind <span class="hljs-keyword">then</span><br>                    leaveStr = leaveStr .. <span class="hljs-built_in">char</span><br>                <span class="hljs-keyword">end</span><br>                oldChar = <span class="hljs-built_in">char</span><br>                lastSubString = substring<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> IsNullOrEmpty(leaveStr) <span class="hljs-keyword">then</span><br>                line = leaveStr<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> IsNullOrEmpty(line) <span class="hljs-keyword">then</span><br>                line = line .. separator<br>            <span class="hljs-keyword">end</span><br>            line = line .. word<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    wrappedText = wrappedText .. line<br>    <span class="hljs-keyword">return</span> wrappedText<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">---计算text组件文本的宽度</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetTextPreferredWidth</span><span class="hljs-params">(textComponent, str)</span></span><br>    <span class="hljs-keyword">return</span> textComponent.cachedTextGenerator:GetPreferredWidth(str, textComponent:GetGenerationSettings(textComponent.rectTransform.rect.size))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SetEnable</span><span class="hljs-params">(state)</span></span><br>    isEnable = state<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IsNullOrEmpty</span><span class="hljs-params">(str)</span></span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">not</span> str) <span class="hljs-keyword">or</span> str == <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>Github链接：<br>    <a href="https://github.com/momohola/Unity-hyphen_util">https://github.com/momohola/Unity-hyphen_util</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
